                   
                   ; ***********************
                   ; * Output Test Program *
                   ; ***********************
                   
                   ; This program tests the print_* functions.
                   
                   ; text:    "Hello, World!"
                   ; hex_8:   hex numbers 00..ff
                   ; hex_16:  hex numbers 0000..ffff in steps of 55 (hex)
                   ; hex_32:  fibonacci sequence (in hex)
                   ; int_u8:  all integers from 0 to 255
                   ; int_s8:  all integers from -128 to 127
                   ; int_u16: integers from 0 to 65535 in steps of 51 (decimal)
                   ; int_s16: start at -32768 and add 127 until signed overflow
                   ; int_u32: fibonacci sequence (in decimal)
                   ; int_s32: start at -2147483648 and add 123456789 repeatedly
                   
                   
                   ; **********************
                   ; * Header Definitions *
                   ; **********************
                   
                   ; *** global/variables.equ ***
                   
                   ; variables in internal RAM
                   
                   ; 0x00-0x1f: register banks 0-3
                   ; 0x20-0x2f: bit addressable variables
                   
0000:              .equ    in,             0x30    ; pointer to input handling 
0000:              .equ    out,            0x32    ; pointer to ouput handling 
                   
0000:              .equ    stream_in,      0x34    ; input stream position
0000:              .equ    stream_out,     0x36    ; output stream position
                   
0000:              .equ    memory_list,    0x38    ; pointer to heap list head
0000:              .equ    memory_start,   0x40    ; first allocatable address
0000:              .equ    memory_end,     0x42    ; last allocatable address
                   
0000:              .equ    block_read,     0x44    ; pointers to block device d
0000:              .equ    block_write,    0x46    ; code (read and write funct
0000:              .equ    block_cache,    0x48    ; pointer to block cache dat
                   
0000:              .equ    fatfs_info,     0x50    ; pointer to FAT file system
                   
0000:              .equ    stack,          0x60    ; beginning of stack (grows 
                   
                   ; *** serial/sfr.equ ***
                   
                   ; Special function registers for serial interface.
                   ; See chapter 14 of AT89C51ED2 datasheet, page 48ff.
                   
                   ; Internal Baud Rate Generator (BRG), see datasheet page 52.
0000:                      .equ    BRL,    0x9A    ; baud rate reload value
0000:                      .equ    BDRCON, 0x9B    ; BRG control register
                   
                   
                   ; *************
                   ; * Main Code *
                   ; *************
                   
0000:                      .org    0
                   
                   ; *** global/init.inc ***
                   
                   ; Initialize stack pointer and global variables.
                   ; This must be included early in the main program.
                   
                   global_init:
0000: 75 81 60             mov     SP,#STACK
                   
                   ; Select register bank zero, clear processor flags
0003: 75 D0 00             mov     PSW,#0
                   
                   ; Fill internal RAM with markers for uninitialized data
0006: 78 00                mov     r0,#0 ; write pointer
                   
0008: 74 3F                mov     a,#0x3f ; '?' for uninitialized registers
                   global_init__1:
000A: 08                   inc     r0 ; first iteration skips address 0, r0 liv
000B: F6                   mov     @r0,a
000C: B8 1F FB             cjne    r0,#0x1f,global_init__1
                   
000F: 74 2A                mov     a,#0x2a ; '*' for uninitialized variables
                   global_init__2:
0011: 08                   inc     r0
0012: F6                   mov     @r0,a
0013: B8 5F FB             cjne    r0,#STACK-1,global_init__2
                   
0016: 74 7E                mov     a,#0x7e ; '~' for stack and above
                   global_init__3:
0018: 08                   inc     r0
0019: F6                   mov     @r0,a
001A: B8 FF FB             cjne    r0,#0xff,global_init__3
                   
                   ; *** test/print.asm ***
                   
001D: 31 92                acall   serial_init
                   
                   ; test print_text
001F: 90 01 80             mov     dptr,   #test__text
0022: 31 C3                acall   print_text
0024: 90 01 8D             mov     dptr,   #test__newline
0027: 31 C3                acall   print_text
                   
                   ; test print_hex_8
0029: E4                   clr     a
                   test_hex_8__loop:
002A: 31 D9                acall   print_hex_8
002C: 24 01                add     a,      #1
002E: 20 D6 07             jb      AC,     test_hex_8__newline
0031: 90 01 90             mov     dptr,   #test__space
0034: 31 C3                acall   print_text
0036: 80 F2                sjmp    test_hex_8__loop
                   test_hex_8__newline:
0038: 90 01 8D             mov     dptr,   #test__newline
003B: 31 C3                acall   print_text
003D: 70 EB                jnz     test_hex_8__loop
                   test_hex_8__end:
003F: 31 C3                acall   print_text
                   
                   ; test print_hex_16
0041: 78 00                mov     r0,     #0
0043: 79 00                mov     r1,     #0
0045: 7B 0C                mov     r3,     #12
                   test_hex_16__loop:
0047: 31 EE                acall   print_hex_16
0049: E8                   mov     a,      r0
004A: 24 55                add     a,      #0x55
004C: F8                   mov     r0,     a
004D: E9                   mov     a,      r1
004E: 34 00                addc    a,      #0
0050: F9                   mov     r1,     a
0051: 40 12                jc      test_hex_16__end
0053: DB 09                djnz    r3,     test_hex_16__space
0055: 7B 0C                mov     r3,     #12
0057: 90 01 8D             mov     dptr,   #test__newline
005A: 31 C3                acall   print_text
005C: 80 E9                sjmp    test_hex_16__loop
                   test_hex_16__space:
005E: 90 01 90             mov     dptr,   #test__space
0061: 31 C3                acall   print_text
0063: 80 E2                sjmp    test_hex_16__loop
                   test_hex_16__end:
0065: 90 01 8D             mov     dptr,   #test__newline
0068: 31 C3                acall   print_text
006A: 31 C3                acall   print_text
                   
                   ; test print_hex_32
006C: 90 01 8D             mov     dptr,   #test__newline
006F: E4                   clr     a
0070: F8                   mov     r0,     a
0071: F9                   mov     r1,     a
0072: FA                   mov     r2,     a
0073: FB                   mov     r3,     a
0074: 7C 01                mov     r4,     #1
0076: FD                   mov     r5,     a
0077: FE                   mov     r6,     a
0078: FF                   mov     r7,     a
                   test_hex_32__loop:
0079: 31 F9                acall   print_hex_32
007B: 31 C3                acall   print_text
                           ; r0-3 += r4-7
007D: E8                   mov     a,      r0
007E: 2C                   add     a,      r4
007F: F8                   mov     r0,     a
0080: E9                   mov     a,      r1
0081: 3D                   addc    a,      r5
0082: F9                   mov     r1,     a
0083: EA                   mov     a,      r2
0084: 3E                   addc    a,      r6
0085: FA                   mov     r2,     a
0086: EB                   mov     a,      r3
0087: 3F                   addc    a,      r7
0088: FB                   mov     r3,     a
                           ; swap r0-3 with r4-7
0089: EC                   mov     a,      r4
008A: C8                   xch     a,      r0
008B: FC                   mov     r4,     a
008C: ED                   mov     a,      r5
008D: C9                   xch     a,      r1
008E: FD                   mov     r5,     a
008F: EE                   mov     a,      r6
0090: CA                   xch     a,      r2
0091: FE                   mov     r6,     a
0092: EF                   mov     a,      r7
0093: CB                   xch     a,      r3
0094: FF                   mov     r7,     a
0095: 50 E2                jnc     test_hex_32__loop
                   test_hex_32__end:
0097: 31 F9                acall   print_hex_32
0099: 31 C3                acall   print_text
009B: 31 C3                acall   print_text
                   
                   ; test print_int_u8
009D: E4                   clr     a
                   test_int_u8__loop:
009E: 51 1D                acall   print_int_u8
00A0: 24 01                add     a,      #1
00A2: 20 D6 07             jb      AC,     test_int_u8__newline
00A5: 90 01 90             mov     dptr,   #test__space
00A8: 31 C3                acall   print_text
00AA: 80 F2                sjmp    test_int_u8__loop
                   test_int_u8__newline:
00AC: 90 01 8D             mov     dptr,   #test__newline
00AF: 31 C3                acall   print_text
00B1: 70 EB                jnz     test_int_u8__loop
                   test_int_u8__end:
00B3: 31 C3                acall   print_text
                   
                   ; test print_int_s8
00B5: 74 80                mov     a,      #0x80
                   test_int_s8__loop:
00B7: 51 0A                acall   print_int_s8
00B9: 24 01                add     a,      #1
00BB: 20 D2 11             jb      OV,     test_int_s8__end
00BE: 20 D6 07             jb      AC,     test_int_s8__newline
00C1: 90 01 90             mov     dptr,   #test__space
00C4: 31 C3                acall   print_text
00C6: 80 EF                sjmp    test_int_s8__loop
                   test_int_s8__newline:
00C8: 90 01 8D             mov     dptr,   #test__newline
00CB: 31 C3                acall   print_text
00CD: 80 E8                sjmp    test_int_s8__loop
                   test_int_s8__end:
00CF: 90 01 8D             mov     dptr,   #test__newline
00D2: 31 C3                acall   print_text
00D4: 31 C3                acall   print_text
                   
                   ; test print_hex_u16
00D6: 78 00                mov     r0,     #0
00D8: 79 00                mov     r1,     #0
00DA: 7B 0A                mov     r3,     #10
                   test_int_u16__loop:
00DC: 51 69                acall   print_int_u16
00DE: E8                   mov     a,      r0
00DF: 24 33                add     a,      #51
00E1: F8                   mov     r0,     a
00E2: E9                   mov     a,      r1
00E3: 34 00                addc    a,      #0
00E5: F9                   mov     r1,     a
00E6: 40 12                jc      test_int_u16__end
00E8: DB 09                djnz    r3,     test_int_u16__space
00EA: 7B 0A                mov     r3,     #10
00EC: 90 01 8D             mov     dptr,   #test__newline
00EF: 31 C3                acall   print_text
00F1: 80 E9                sjmp    test_int_u16__loop
                   test_int_u16__space:
00F3: 90 01 90             mov     dptr,   #test__space
00F6: 31 C3                acall   print_text
00F8: 80 E2                sjmp    test_int_u16__loop
                   test_int_u16__end:
00FA: 90 01 8D             mov     dptr,   #test__newline
00FD: 31 C3                acall   print_text
00FF: 31 C3                acall   print_text
                   
                   ; test print_hex_s16
0101: 78 00                mov     r0,     #0
0103: 79 80                mov     r1,     #0x80
0105: 7B 0A                mov     r3,     #10
                   test_int_s16__loop:
0107: 51 4E                acall   print_int_s16
0109: E8                   mov     a,      r0
010A: 24 7F                add     a,      #127
010C: F8                   mov     r0,     a
010D: E9                   mov     a,      r1
010E: 34 00                addc    a,      #0
0110: F9                   mov     r1,     a
0111: 20 D2 12             jb      OV,     test_int_s16__end
0114: DB 09                djnz    r3,     test_int_s16__space
0116: 7B 0A                mov     r3,     #10
0118: 90 01 8D             mov     dptr,   #test__newline
011B: 31 C3                acall   print_text
011D: 80 E8                sjmp    test_int_s16__loop
                   test_int_s16__space:
011F: 90 01 90             mov     dptr,   #test__space
0122: 31 C3                acall   print_text
0124: 80 E1                sjmp    test_int_s16__loop
                   test_int_s16__end:
0126: 90 01 8D             mov     dptr,   #test__newline
0129: 31 C3                acall   print_text
012B: 31 C3                acall   print_text
                   
                   ; test print_int_u32
012D: 90 01 8D             mov     dptr,   #test__newline
0130: E4                   clr     a
0131: F8                   mov     r0,     a
0132: F9                   mov     r1,     a
0133: FA                   mov     r2,     a
0134: FB                   mov     r3,     a
0135: 7C 01                mov     r4,     #1
0137: FD                   mov     r5,     a
0138: FE                   mov     r6,     a
0139: FF                   mov     r7,     a
                   test_int_u32__loop:
013A: 71 32                acall   print_int_u32
013C: 31 C3                acall   print_text
                           ; r0-3 += r4-7
013E: E8                   mov     a,      r0
013F: 2C                   add     a,      r4
0140: F8                   mov     r0,     a
0141: E9                   mov     a,      r1
0142: 3D                   addc    a,      r5
0143: F9                   mov     r1,     a
0144: EA                   mov     a,      r2
0145: 3E                   addc    a,      r6
0146: FA                   mov     r2,     a
0147: EB                   mov     a,      r3
0148: 3F                   addc    a,      r7
0149: FB                   mov     r3,     a
                           ; swap r0-3 with r4-7
014A: EC                   mov     a,      r4
014B: C8                   xch     a,      r0
014C: FC                   mov     r4,     a
014D: ED                   mov     a,      r5
014E: C9                   xch     a,      r1
014F: FD                   mov     r5,     a
0150: EE                   mov     a,      r6
0151: CA                   xch     a,      r2
0152: FE                   mov     r6,     a
0153: EF                   mov     a,      r7
0154: CB                   xch     a,      r3
0155: FF                   mov     r7,     a
0156: 50 E2                jnc     test_int_u32__loop
                   test_int_u32__end:
0158: 71 32                acall   print_int_u32
015A: 31 C3                acall   print_text
015C: 31 C3                acall   print_text
                   
                   ; test print_int_s32
015E: 90 01 8D             mov     dptr,   #test__newline
                           ; r0-r3 <- 0x80000000 (-2147483648)
0161: E4                   clr     a
0162: F8                   mov     r0,     a
0163: F9                   mov     r1,     a
0164: FA                   mov     r2,     a
0165: 7B 80                mov     r3,     #0x80
                   test_int_s32_loop:
0167: 71 00                acall   print_int_s32
0169: 31 C3                acall   print_text
                           ; r0-r3 += 0x075bcd15 (123456789)
016B: E8                   mov     a,      r0
016C: 24 15                add     a,      #0x15
016E: F8                   mov     r0,     a
016F: E9                   mov     a,      r1
0170: 34 CD                addc    a,      #0xcd
0172: F9                   mov     r1,     a
0173: EA                   mov     a,      r2
0174: 34 5B                addc    a,      #0x5b
0176: FA                   mov     r2,     a
0177: EB                   mov     a,      r3
0178: 34 07                addc    a,      #0x07
017A: FB                   mov     r3,     a
017B: 30 D2 E9             jnb     ov,     test_int_s32_loop
                   
                   ; the end
017E: 21 7E                ajmp    *
                   
                   test__text:
0180: 48 65 6C 6C 
      6F 2C 20 77 
      6F 72 6C 64 
      21                   .byte   "Hello, world!"
                   test__newline:
018D: 0D 0A 00             .byte   13, 10, 0
                   test__space:
0190: 20 00                .byte   32, 0
                   
                   ; *********************
                   ; * Library Functions *
                   ; *********************
                   
                   ; *** serial/init.inc ***
                   
                   ; >> void serial_init() <<
                   
                   ; Initialize serial interface.
                   ; - assumes 20MHz clock and X2 mode
                   ; - uses internal baud rate generator
                   ; - speed: 9600 bits per second
                   ; Formula: BRL = 256 - (F_clk / (32 * Baud_Rate))
                   ; ---
                   ; See datasheet page 52 for details,
                   ; also note oscillator diagram on page 16!
                   
                   serial_init:
0192: 75 98 52             mov     SCON,   #0x52   ; SM1, REN, TI
0195: 75 9A BF             mov     BRL,    #191    ; 9600 @20MHz CLK
0198: 75 9B 1E             mov     BDRCON, #0x1e   ; BRR, RBCK, TBCK, SPD
                   
019B: 90 01 AE             mov     dptr,   #serial_rx
019E: 85 82 30             mov     IN,     DPL
01A1: 85 83 31             mov     IN+1,   DPH
                   
01A4: 90 01 B6             mov     dptr,   #serial_tx
01A7: 85 82 32             mov     OUT,    DPL
01AA: 85 83 33             mov     OUT+1,  DPH
                   
01AD: 22                   ret
                   
                   ; *** serial/rx.inc ***
                   
                   ; >> char serial_rx <<
                   
                   ; Receive byte into accumulator.
                   
                   serial_rx:
01AE: 30 98 FD             jnb     RI,     serial_rx
01B1: C2 98                clr     RI
01B3: E5 99                mov     a,      SBUF
01B5: 22                   ret
                   
                   ; *** serial/tx.inc ***
                   
                   ; >> void serial_tx(char a) <<
                   
                   ; Transmit byte from accumulator.
                   
                   serial_tx:
01B6: 30 99 FD             jnb     TI,     serial_tx
01B9: C2 99                clr     TI
01BB: F5 99                mov     SBUF,   a
01BD: 22                   ret
                   
                   ; *** print/char.inc ***
                   
                   ; >> void print_char(char a) <<
                   
                   ; Print char from accumulator.
                   ; Indirect call to function behind OUT pointer.
                   
                   print_char:
01BE: C0 32                push    OUT
01C0: C0 33                push    OUT+1
01C2: 22                   ret
                   
                   ; *** print/text.inc ***
                   
                   ; >> void print_text(char* dptr) <<
                   
                   ; Print null-terminated string from program code.
                   ; Aborts if no null terminator is found after 256 bytes.
                   
                   print_text:
01C3: C0 E0                push    ACC
01C5: E8                   mov     a,      r0
01C6: C0 E0                push    ACC
                   
01C8: E4                   clr     a
01C9: F8                   mov     r0,     a
                   print_text__loop:
01CA: 93                   movc    a,      @dptr+a
01CB: 60 06                jz      print_text__end
01CD: 31 BE                acall   print_char
01CF: 08                   inc     r0
01D0: E8                   mov     a,      r0
01D1: 70 F7                jnz     print_text__loop
                   
                   print_text__end:
01D3: D0 E0                pop     ACC
01D5: F8                   mov     r0,     a
01D6: D0 E0                pop     ACC
01D8: 22                   ret
                   
                   ; *** print/hex.inc ***
                   
                   ; >> void print_hex_8(char a) <<
                   
                   ; Print hexadecimal number from accumulator.
                   
                   print_hex_8:
01D9: C4                   swap    a       ; high nibble first
01DA: 31 DD                acall   print_hex_8__nibble
01DC: C4                   swap    a
                   print_hex_8__nibble:
01DD: C0 E0                push    ACC
01DF: 54 0F                anl     a,      #0x0f
01E1: 24 90                add     a,      #0x90
01E3: D4                   da      a
01E4: 34 40                addc    a,      #0x40
01E6: D4                   da      a
01E7: 44 20                orl     a,      #0x20   ; lower case
01E9: 31 BE                acall   print_char
01EB: D0 E0                pop     ACC
01ED: 22                   ret
                   
                   ; >> void print_hex_16(int r0r1) <<
                   
                   ; Print hexadecimal number from r0-r1.
                   
                   print_hex_16:
01EE: C0 E0                push    ACC
01F0: E9                   mov     a,      r1      ; MSB first
01F1: 31 D9                acall   print_hex_8
01F3: E8                   mov     a,      r0      ; LSB second
01F4: 31 D9                acall   print_hex_8
01F6: D0 E0                pop     ACC
01F8: 22                   ret
                   
                   ; >> void print_hex_32(long r0r1r2r3) <<
                   
                   ; Print hexadecimal number from r0-r3.
                   
                   print_hex_32:
01F9: C0 E0                push    ACC
01FB: EB                   mov     a,      r3      ; MSB first
01FC: 31 D9                acall   print_hex_8
01FE: EA                   mov     a,      r2
01FF: 31 D9                acall   print_hex_8
0201: E9                   mov     a,      r1
0202: 31 D9                acall   print_hex_8
0204: E8                   mov     a,      r0      ; LSB last
0205: 31 D9                acall   print_hex_8
0207: D0 E0                pop     ACC
0209: 22                   ret
                   
                   ; *** print/int.inc ***
                   
                   ; >> void print_int_s8(char a) <<
                   
                   ; Print signed integer from accumulator.
                   
                   print_int_s8:
020A: C0 E0                push    ACC
020C: C0 F0                push    B
020E: 30 E7 10             jnb     ACC.7,  print_int_u8__1
0211: F5 F0                mov     b,      a
0213: 74 2D                mov     a,      #'-'
0215: 31 BE                acall   print_char
0217: E5 F0                mov     a,      b
0219: F4                   cpl     a
021A: 04                   inc     a
021B: 80 04                sjmp    print_int_u8__1
                   
                   ; >> void print_int_u8(char a) <<
                   
                   ; Print unsingned integer from accumulator.
                   
                   print_int_u8:
021D: C0 E0                push    ACC
021F: C0 F0                push    B
                   print_int_u8__1:
0221: 88 F0                mov     b,      r0
0223: C0 F0                push    B
                   
0225: 78 00                mov     r0,     #0
0227: 75 F0 64             mov     b,      #100
022A: 84                   div     ab
022B: 60 05                jz      print_int_u8__tens
022D: 24 30                add     a,      #'0'
022F: 31 BE                acall   print_char
0231: 08                   inc     r0      ; stop skipping leading zeroes
                   print_int_u8__tens:
0232: E5 F0                mov     a,      b
0234: 75 F0 0A             mov     b,      #10
0237: 84                   div     ab
0238: 28                   add     a,      r0
0239: 60 05                jz      print_int_u8__ones
023B: 98                   subb    a,      r0
023C: 24 30                add     a,      #'0'
023E: 31 BE                acall   print_char
                   print_int_u8__ones:
0240: E5 F0                mov     a,      b
0242: 24 30                add     a,      #'0'
0244: 31 BE                acall   print_char
                   
0246: D0 E0                pop     ACC
0248: F8                   mov     r0,     a
0249: D0 F0                pop     B
024B: D0 E0                pop     ACC
024D: 22                   ret
                   
                   ; >> void print_int_s16(int r0r1) <<
                   
                   ; Print signed integer from r0-r1.
                   
                   print_int_s16:
024E: C0 E0                push    ACC
0250: E8                   mov     a,      r0
0251: C0 E0                push    ACC
0253: E9                   mov     a,      r1
0254: C0 E0                push    ACC
0256: 30 E7 18             jnb     ACC.7,  print_int_u16__1
0259: 74 2D                mov     a,      #'-'
025B: 31 BE                acall   print_char
025D: E8                   mov     a,      r0
025E: F4                   cpl     a
025F: 24 01                add     a,      #1
0261: F8                   mov     r0,     a
0262: E9                   mov     a,      r1
0263: F4                   cpl     a
0264: 34 00                addc    a,      #0
0266: F9                   mov     r1,     a
0267: 80 08                sjmp    print_int_u16__1
                   
                   ; >> void print_int_u16(int r0r1) <<
                   
                   ; Print unsigned integer from r0-r1.
                   
                   print_int_u16:
0269: C0 E0                push    ACC
026B: E8                   mov     a,      r0
026C: C0 E0                push    ACC
026E: E9                   mov     a,      r1
026F: C0 E0                push    ACC
                   print_int_u16__1:
0271: EB                   mov     a,      r3
0272: C0 E0                push    ACC
0274: C0 F0                push    B
                   
0276: 7A 00                mov     r2,     #0 ; flag for leading zeroes
                   
                           ; divide by 10000 (0x2710)
                           ; collect quotient in b
0278: 75 F0 FF             mov     b,      #-1
027B: C3                   clr     c
                   print_int_u16__10k_loop:
027C: E8                   mov     a,      r0
027D: 94 10                subb    a,      #0x10
027F: F8                   mov     r0,     a
0280: E9                   mov     a,      r1
0281: 94 27                subb    a,      #0x27
0283: F9                   mov     r1,     a
0284: 05 F0                inc     b
0286: 50 F4                jnc     print_int_u16__10k_loop
                           ; undo last subtraction to restore remainder
0288: E8                   mov     a,      r0
0289: 24 10                add     a,      #0x10
028B: F8                   mov     r0,     a
028C: E9                   mov     a,      r1
028D: 34 27                addc    a,      #0x27
028F: F9                   mov     r1,     a
                           ; print tenthousands digit
0290: E5 F0                mov     a,      b
0292: 60 05                jz      print_int_u16__1k
0294: 24 30                add     a,      #'0'
0296: 31 BE                acall   print_char
0298: 0A                   inc     r2
                   print_int_u16__1k:
                           ; divide by 1000 (0x03e8)
                           ; collect quotient in b
0299: 75 F0 FF             mov     b,      #-1
029C: C3                   clr     c
                   print_int_u16__1k_loop:
029D: E8                   mov     a,      r0
029E: 94 E8                subb    a,      #0xe8
02A0: F8                   mov     r0,     a
02A1: E9                   mov     a,      r1
02A2: 94 03                subb    a,      #0x03
02A4: F9                   mov     r1,     a
02A5: 05 F0                inc     b
02A7: 50 F4                jnc     print_int_u16__1k_loop
                           ; undo last subtraction to restore remainder
02A9: E8                   mov     a,      r0
02AA: 24 E8                add     a,      #0xe8
02AC: F8                   mov     r0,     a
02AD: E9                   mov     a,      r1
02AE: 34 03                addc    a,      #0x03
02B0: F9                   mov     r1,     a
                           ; print thousands digit
02B1: E5 F0                mov     a,      b
02B3: 2A                   add     a,      r2
02B4: 60 06                jz      print_int_u16__100
02B6: 9A                   subb    a,      r2
02B7: 24 30                add     a,      #'0'
02B9: 31 BE                acall   print_char
02BB: 0A                   inc     r2
                   print_int_u16__100:
                           ; divide by 100 (0x0064)
                           ; collect quotient in b
02BC: 75 F0 FF             mov     b,      #-1
02BF: C3                   clr     c
                   print_int_u16__100_loop:
02C0: E8                   mov     a,      r0
02C1: 94 64                subb    a,      #0x64
02C3: F8                   mov     r0,     a
02C4: E9                   mov     a,      r1
02C5: 94 00                subb    a,      #0x00
02C7: F9                   mov     r1,     a
02C8: 05 F0                inc     b
02CA: 50 F4                jnc     print_int_u16__100_loop
                           ; undo last subtraction to restore remainder
02CC: E8                   mov     a,      r0
02CD: 24 64                add     a,      #0x64
02CF: F8                   mov     r0,     a
02D0: E9                   mov     a,      r1
02D1: 34 00                addc    a,      #0x00
02D3: F9                   mov     r1,     a
                           ; print hundreds digit
02D4: E5 F0                mov     a,      b
02D6: 2A                   add     a,      r2
02D7: 60 06                jz      print_int_u16__tens
02D9: 9A                   subb    a,      r2
02DA: 24 30                add     a,      #'0'
02DC: 31 BE                acall   print_char
02DE: 0A                   inc     r2
                   print_int_u16__tens:
                           ; divide by 10 (using div instruction)
02DF: E8                   mov     a,      r0
02E0: 75 F0 0A             mov     b,      #10
02E3: 84                   div     ab
                           ; print tens digit
02E4: 2A                   add     a,      r2
02E5: 60 05                jz      print_int_u16__ones
02E7: 9A                   subb    a,      r2
02E8: 24 30                add     a,      #'0'
02EA: 31 BE                acall   print_char
                   print_int_u16__ones:
                           ; print ones digit
02EC: E5 F0                mov     a,      b
02EE: 24 30                add     a,      #'0'
02F0: 31 BE                acall   print_char
                   
02F2: D0 F0                pop     B
02F4: D0 E0                pop     ACC
02F6: FA                   mov     r2,     a
02F7: D0 E0                pop     ACC
02F9: F9                   mov     r1,     a
02FA: D0 E0                pop     ACC
02FC: F8                   mov     r0,     a
02FD: D0 E0                pop     ACC
02FF: 22                   ret
                   
                   ; >> void print_int_s32(long r0r1r2r3) <<
                   
                   ; Print signed integer from r0-r3.
                   
                   print_int_s32:
0300: C0 E0                push    acc
0302: C0 F0                push    b
0304: C0 82                push    dpl
0306: C0 83                push    dph
0308: 71 C9                acall   regbank_next
                           ; r4-r7: value to print
030A: E6                   mov     a,      @r0
030B: FC                   mov     r4,     a
030C: 08                   inc     r0
030D: E6                   mov     a,      @r0
030E: FD                   mov     r5,     a
030F: 08                   inc     r0
0310: E6                   mov     a,      @r0
0311: FE                   mov     r6,     a
0312: 08                   inc     r0
0313: E6                   mov     a,      @r0
0314: FF                   mov     r7,     a
0315: 30 E7 2F             jnb     ACC.7,  print_int_u32__1
0318: 74 2D                mov     a,      #'-'
031A: 31 BE                acall   print_char
031C: EC                   mov     a,      r4
031D: F4                   cpl     a
031E: 24 01                add     a,      #1
0320: FC                   mov     r4,     a
0321: ED                   mov     a,      r5
0322: F4                   cpl     a
0323: 34 00                addc    a,      #0
0325: FD                   mov     r5,     a
0326: EE                   mov     a,      r6
0327: F4                   cpl     a
0328: 34 00                addc    a,      #0
032A: FE                   mov     r6,     a
032B: EF                   mov     a,      r7
032C: F4                   cpl     a
032D: 34 00                addc    a,      #0
032F: FF                   mov     r7,     a
0330: 80 15                sjmp    print_int_u32__1
                   
                   
                   ; >> void print_int_u32(long r0r1r2r3) <<
                   
                   ; Print unsigned integer from r0-r3.
                   
                   print_int_u32:
0332: C0 E0                push    acc
0334: C0 F0                push    b
0336: C0 82                push    dpl
0338: C0 83                push    dph
033A: 71 C9                acall   regbank_next
                           ; r4-r7: value to print
033C: E6                   mov     a,      @r0
033D: FC                   mov     r4,     a
033E: 08                   inc     r0
033F: E6                   mov     a,      @r0
0340: FD                   mov     r5,     a
0341: 08                   inc     r0
0342: E6                   mov     a,      @r0
0343: FE                   mov     r6,     a
0344: 08                   inc     r0
0345: E6                   mov     a,      @r0
0346: FF                   mov     r7,     a
                   print_int_u32__1:
0347: 75 F0 00             mov     b,      #0 ; flag for leading zeroes
034A: 90 03 7E             mov     dptr,   #print_int_u32__divisors
                   print_int_u32__loop:
                           ; get divisor
034D: E4                   clr     a
034E: 93                   movc    a,      @a+dptr
034F: F8                   mov     r0,     a
0350: A3                   inc     dptr
0351: E4                   clr     a
0352: 93                   movc    a,      @a+dptr
0353: F9                   mov     r1,     a
0354: A3                   inc     dptr
0355: E4                   clr     a
0356: 93                   movc    a,      @a+dptr
0357: FA                   mov     r2,     a
0358: A3                   inc     dptr
0359: E4                   clr     a
035A: 93                   movc    a,      @a+dptr
035B: FB                   mov     r3,     a
035C: A3                   inc     dptr
                           ; divide r4-r7 by r0-r3
035D: 71 A2                acall   print_int_u32__divide
035F: 25 F0                add     a,      b
0361: 60 08                jz      print_int_u32__skip ; leading zero
0363: 95 F0                subb    a,      b
0365: 24 30                add     a,      #'0'
0367: 05 F0                inc     b
0369: 31 BE                acall   print_char
                   print_int_u32__skip:
036B: B8 0A DF             cjne    r0,     #0x0a,  print_int_u32__loop
036E: EC                   mov     a,      r4
036F: 24 30                add     a,      #'0'
0371: 31 BE                acall   print_char
                   
0373: 71 E2                acall   regbank_prev
0375: D0 83                pop     dph
0377: D0 82                pop     dpl
0379: D0 F0                pop     b
037B: D0 E0                pop     acc
037D: 22                   ret
                   ; Divisor table:
                   print_int_u32__divisors:
                           ; 1,000,000,000 = 3b9aca00
037E: 00 CA 9A 3B 
                           .db     0x00, 0xca, 0x9a, 0x3b
                           ;   100,000,000 = 05f5e100
0382: 00 E1 F5 05 
                           .db     0x00, 0xe1, 0xf5, 0x05
                           ;    10,000,000 = 00989680
0386: 80 96 98 00 
                           .db     0x80, 0x96, 0x98, 0x00
                           ;     1,000,000 = 000f4240
038A: 40 42 0F 00 
                           .db     0x40, 0x42, 0x0f, 0x00
                           ;       100,000 = 000186a0
038E: A0 86 01 00 
                           .db     0xa0, 0x86, 0x01, 0x00
                           ;        10,000 = 00002710
0392: 10 27 00 00 
                           .db     0x10, 0x27, 0x00, 0x00
                           ;         1,000 = 000003e8
0396: E8 03 00 00 
                           .db     0xe8, 0x03, 0x00, 0x00
                           ;           100 = 00000064
039A: 64 00 00 00 
                           .db     0x64, 0x00, 0x00, 0x00
                           ;            10 = 0000000a
039E: 0A 00 00 00 
                           .db     0x0a, 0x00, 0x00, 0x00
                   ; Divide r4-r7 by r0-r1 using repeated subtraction.
                   ; Quotient returned in a, remainder in r4-r7.
                   ; Since the quotient is at most 9,
                   ; this is faster than 'proper' division.
                   print_int_u32__divide:
03A2: C0 F0                push    b
03A4: C3                   clr     c
03A5: 75 F0 FF             mov     b,      #-1
                   print_int_u32__divide_loop:
03A8: EC                   mov     a,      r4
03A9: 98                   subb    a,      r0
03AA: FC                   mov     r4,     a
03AB: ED                   mov     a,      r5
03AC: 99                   subb    a,      r1
03AD: FD                   mov     r5,     a
03AE: EE                   mov     a,      r6
03AF: 9A                   subb    a,      r2
03B0: FE                   mov     r6,     a
03B1: EF                   mov     a,      r7
03B2: 9B                   subb    a,      r3
03B3: FF                   mov     r7,     a
03B4: 05 F0                inc     b
03B6: 50 F0                jnc     print_int_u32__divide_loop
                           ; restore remainder
03B8: EC                   mov     a,      r4
03B9: 28                   add     a,      r0
03BA: FC                   mov     r4,     a
03BB: ED                   mov     a,      r5
03BC: 39                   addc    a,      r1
03BD: FD                   mov     r5,     a
03BE: EE                   mov     a,      r6
03BF: 3A                   addc    a,      r2
03C0: FE                   mov     r6,     a
03C1: EF                   mov     a,      r7
03C2: 3B                   addc    a,      r3
03C3: FF                   mov     r7,     a
03C4: E5 F0                mov     a,      b
03C6: D0 F0                pop     b
03C8: 22                   ret
                   
                   ; *** util/regbank.inc ***
                   
                   ; >> void*{r0} regbank_next() <<
                   
                   ; Switch to next register bank.
                   ; Return pointer to r0 of old bank in new r0.
                   
                   regbank_next:
03C9: C0 E0                push    acc
                           ; check if already at highest bank
03CB: E5 D0                mov     a,      psw
03CD: 54 18                anl     a,      #0x18   ; mask off rs0 and rs1
03CF: B4 18 02             cjne    a,      #0x18,  regbank_next__continue
03D2: 71 F5                acall   panic   ; overflow
                   regbank_next__continue:
                           ; switch to next bank
03D4: E5 D0                mov     a,      psw
03D6: 24 08                add     a,      #0x08
03D8: F5 D0                mov     psw,    a
                           ; calculate pointer to old bank
03DA: 54 18                anl     a,      #0x18
03DC: 24 F8                add     a,      #0xf8 ; subtract 8
03DE: F8                   mov     r0,     a
                           ; done
03DF: D0 E0                pop     acc
03E1: 22                   ret
                   
                   ; >> void regbank_prev() <<
                   
                   ; Switch to previous register bank.
                   
                   regbank_prev:
03E2: C0 E0                push    acc
                           ; check if already at lowest bank
03E4: E5 D0                mov     a,      psw
03E6: 54 18                anl     a,      #0x18
03E8: 70 02                jnz     regbank_prev__continue
03EA: 71 F5                acall   panic   ; underflow
                   regbank_prev__continue:
                           ; switch to previous bank
03EC: E5 D0                mov     a,      psw
03EE: 24 F8                add     a,      #0xf8 ; subtract 8
03F0: F5 D0                mov     psw,    a
                           ; done
03F2: D0 E0                pop     acc
03F4: 22                   ret
                   
03F5:              .equ panic_out, serial_tx
                   
                   ; *** panic/panic.inc ***
                   
                   ; >> void panic() <<
                   
                   ; Unrecoverable error handler.
                   ; Print caller address and halt.
                   
                   panic:
03F5: C2 AF                clr     ea      ; disable interrupts
03F7: F8                   mov     r0,a
03F8: 90 01 B6             mov     dptr,#panic_out
03FB: 85 82 32             mov     out,dpl
03FE: 85 83 33             mov     out+1,dph
0401: 90 04 1F             mov     dptr,#panic_text
0404: 31 C3                acall   print_text
0406: D0 E0                pop     acc
0408: 31 D9                acall   print_hex_8
040A: D0 E0                pop     acc
040C: 31 D9                acall   print_hex_8
040E: 74 20                mov     a,#' '
0410: 31 BE                acall   print_char
0412: E8                   mov     a,r0
0413: 31 D9                acall   print_hex_8
0415: 74 0D                mov     a,#13
0417: 31 BE                acall   print_char
0419: 74 0A                mov     a,#10
041B: 31 BE                acall   print_char
041D: 80 FE                sjmp    *
                   
                   panic_text:
041F: 0D 0A                .db     13, 10
0421: 20 21 21 21 
      20 70 61 6E 
      69 63 20 40 
                           .db     " !!! panic @"
042D: 00                   .db     0
