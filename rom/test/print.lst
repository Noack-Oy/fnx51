                   
                   ; ***********************
                   ; * Output Test Program *
                   ; ***********************
                   
                   ; This program tests the print_* functions.
                   
                   ; text:    "Hello, World!"
                   ; hex_8:   hex numbers 00..ff
                   ; hex_16:  hex numbers 0000..ffff in steps of 55 (hex)
                   ; hex_32:  fibonacci sequence (in hex)
                   ; int_u8:  all integers from 0 to 255
                   ; int_s8:  all integers from -128 to 127
                   ; int_u16: integers from 0 to 65535 in steps of 51 (decimal)
                   ; int_s16: start at -32768 and add 127 until signed overflow
                   ; int_u32: fibonacci sequence (in decimal)
                   ; int_s32: start at -2147483648 and add 123456789 repeatedly
                   
                   
                   ; **********************
                   ; * Header Definitions *
                   ; **********************
                   
                   ; *** global/variables.equ ***
                   
                            ; variables in internal ram
                   
0000:                       .equ    in,     0x30    ; pointer to input code
0000:                       .equ    out,    0x32    ; pointer to ouput code
                   
0000:                       .equ    stack,  0x40    ; beginning of stack
                   
                   ; *** serial/sfr.equ ***
                   
                   ; Special function registers for serial interface.
                   ; See chapter 14 of AT89C51ED2 datasheet, page 48ff.
                   
                   ; Internal Baud Rate Generator (BRG), see datasheet page 52.
0000:                       .equ    BRL,    0x9A    ; baud rate reload value
0000:                       .equ    BDRCON, 0x9B    ; BRG control register
                   
                   
                   ; *************
                   ; * Main Code *
                   ; *************
                   
0000:                       .org    0
                   
                   ; *** global/init.inc ***
                   
                   ; Initialize stack pointer and global variables.
                   ; This must be included early in the main program.
                   
0000: 75 81 40              mov     SP,     #STACK
                   
0003: 90 01 43              mov     dptr,   #serial_rx
0006: 85 82 30              mov     IN,     DPL
0009: 85 83 31              mov     IN+1,   DPH
                   
000C: 90 01 4B              mov     dptr,   #serial_tx
000F: 85 82 32              mov     OUT,    DPL
0012: 85 83 33              mov     OUT+1,  DPH
                   
                   ; *** test/print.asm ***
                   
0015: 31 39                 acall   serial_init
                   
                   ; test print_text
0017: 90 01 27              mov     dptr,   #test__text
001A: 31 58                 acall   print_text
001C: 90 01 34              mov     dptr,   #test__newline
001F: 31 58                 acall   print_text
                   
                   ; test print_hex_8
0021: E4                    clr     a
                   test_hex_8__loop:
0022: 31 6E                 acall   print_hex_8
0024: 24 01                 add     a,      #1
0026: 20 D6 07              jb      AC,     test_hex_8__newline
0029: 90 01 37              mov     dptr,   #test__space
002C: 31 58                 acall   print_text
002E: 80 F2                 sjmp    test_hex_8__loop
                   test_hex_8__newline:
0030: 90 01 34              mov     dptr,   #test__newline
0033: 31 58                 acall   print_text
0035: 70 EB                 jnz     test_hex_8__loop
                   test_hex_8__end:
0037: 31 58                 acall   print_text
                   
                   ; test print_hex_16
0039: 78 00                 mov     r0,     #0
003B: 79 00                 mov     r1,     #0
003D: 7B 0C                 mov     r3,     #12
                   test_hex_16__loop:
003F: 31 83                 acall   print_hex_16
0041: E8                    mov     a,      r0
0042: 24 55                 add     a,      #0x55
0044: F8                    mov     r0,     a
0045: E9                    mov     a,      r1
0046: 34 00                 addc    a,      #0
0048: F9                    mov     r1,     a
0049: 40 12                 jc      test_hex_16__end
004B: DB 09                 djnz    r3,     test_hex_16__space
004D: 7B 0C                 mov     r3,     #12
004F: 90 01 34              mov     dptr,   #test__newline
0052: 31 58                 acall   print_text
0054: 80 E9                 sjmp    test_hex_16__loop
                   test_hex_16__space:
0056: 90 01 37              mov     dptr,   #test__space
0059: 31 58                 acall   print_text
005B: 80 E2                 sjmp    test_hex_16__loop
                   test_hex_16__end:
005D: 90 01 34              mov     dptr,   #test__newline
0060: 31 58                 acall   print_text
0062: 31 58                 acall   print_text
                   
                   ; test print_hex_32
0064: 90 01 34              mov     dptr,   #test__newline
0067: E4                    clr     a
0068: F8                    mov     r0,     a
0069: F9                    mov     r1,     a
006A: FA                    mov     r2,     a
006B: FB                    mov     r3,     a
006C: 7C 01                 mov     r4,     #1
006E: FD                    mov     r5,     a
006F: FE                    mov     r6,     a
0070: FF                    mov     r7,     a
                   test_hex_32__loop:
0071: 31 8E                 acall   print_hex_32
0073: 31 58                 acall   print_text
                            ; r0-3 += r4-7
0075: E8                    mov     a,      r0
0076: 2C                    add     a,      r4
0077: F8                    mov     r0,     a
0078: E9                    mov     a,      r1
0079: 3D                    addc    a,      r5
007A: F9                    mov     r1,     a
007B: EA                    mov     a,      r2
007C: 3E                    addc    a,      r6
007D: FA                    mov     r2,     a
007E: EB                    mov     a,      r3
007F: 3F                    addc    a,      r7
0080: FB                    mov     r3,     a
                            ; swap r0-3 with r4-7
0081: EC                    mov     a,      r4
0082: C8                    xch     a,      r0
0083: FC                    mov     r4,     a
0084: ED                    mov     a,      r5
0085: C9                    xch     a,      r1
0086: FD                    mov     r5,     a
0087: EE                    mov     a,      r6
0088: CA                    xch     a,      r2
0089: FE                    mov     r6,     a
008A: EF                    mov     a,      r7
008B: CB                    xch     a,      r3
008C: FF                    mov     r7,     a
008D: 50 E2                 jnc     test_hex_32__loop
                   test_hex_32__end:
008F: 31 8E                 acall   print_hex_32
0091: 31 58                 acall   print_text
0093: 31 58                 acall   print_text
                   
                   ; test print_int_u8
0095: E4                    clr     a
                   test_int_u8__loop:
0096: 31 B2                 acall   print_int_u8
0098: 24 01                 add     a,      #1
009A: 20 D6 07              jb      AC,     test_int_u8__newline
009D: 90 01 37              mov     dptr,   #test__space
00A0: 31 58                 acall   print_text
00A2: 80 F2                 sjmp    test_int_u8__loop
                   test_int_u8__newline:
00A4: 90 01 34              mov     dptr,   #test__newline
00A7: 31 58                 acall   print_text
00A9: 70 EB                 jnz     test_int_u8__loop
                   test_int_u8__end:
00AB: 31 58                 acall   print_text
                   
                   ; test print_int_s8
00AD: 74 80                 mov     a,      #0x80
                   test_int_s8__loop:
00AF: 31 9F                 acall   print_int_s8
00B1: 24 01                 add     a,      #1
00B3: 20 D2 11              jb      OV,     test_int_s8__end
00B6: 20 D6 07              jb      AC,     test_int_s8__newline
00B9: 90 01 37              mov     dptr,   #test__space
00BC: 31 58                 acall   print_text
00BE: 80 EF                 sjmp    test_int_s8__loop
                   test_int_s8__newline:
00C0: 90 01 34              mov     dptr,   #test__newline
00C3: 31 58                 acall   print_text
00C5: 80 E8                 sjmp    test_int_s8__loop
                   test_int_s8__end:
00C7: 90 01 34              mov     dptr,   #test__newline
00CA: 31 58                 acall   print_text
00CC: 31 58                 acall   print_text
                   
                   ; test print_hex_u16
00CE: 78 00                 mov     r0,     #0
00D0: 79 00                 mov     r1,     #0
00D2: 7B 0A                 mov     r3,     #10
                   test_int_u16__loop:
00D4: 31 FE                 acall   print_int_u16
00D6: E8                    mov     a,      r0
00D7: 24 33                 add     a,      #51
00D9: F8                    mov     r0,     a
00DA: E9                    mov     a,      r1
00DB: 34 00                 addc    a,      #0
00DD: F9                    mov     r1,     a
00DE: 40 12                 jc      test_int_u16__end
00E0: DB 09                 djnz    r3,     test_int_u16__space
00E2: 7B 0A                 mov     r3,     #10
00E4: 90 01 34              mov     dptr,   #test__newline
00E7: 31 58                 acall   print_text
00E9: 80 E9                 sjmp    test_int_u16__loop
                   test_int_u16__space:
00EB: 90 01 37              mov     dptr,   #test__space
00EE: 31 58                 acall   print_text
00F0: 80 E2                 sjmp    test_int_u16__loop
                   test_int_u16__end:
00F2: 90 01 34              mov     dptr,   #test__newline
00F5: 31 58                 acall   print_text
00F7: 31 58                 acall   print_text
                   
                   ; test print_hex_s16
00F9: 78 00                 mov     r0,     #0
00FB: 79 80                 mov     r1,     #0x80
00FD: 7B 0A                 mov     r3,     #10
                   test_int_s16__loop:
00FF: 31 E3                 acall   print_int_s16
0101: E8                    mov     a,      r0
0102: 24 7F                 add     a,      #127
0104: F8                    mov     r0,     a
0105: E9                    mov     a,      r1
0106: 34 00                 addc    a,      #0
0108: F9                    mov     r1,     a
0109: 20 D2 12              jb      OV,     test_int_s16__end
010C: DB 09                 djnz    r3,     test_int_s16__space
010E: 7B 0A                 mov     r3,     #10
0110: 90 01 34              mov     dptr,   #test__newline
0113: 31 58                 acall   print_text
0115: 80 E8                 sjmp    test_int_s16__loop
                   test_int_s16__space:
0117: 90 01 37              mov     dptr,   #test__space
011A: 31 58                 acall   print_text
011C: 80 E1                 sjmp    test_int_s16__loop
                   test_int_s16__end:
011E: 90 01 34              mov     dptr,   #test__newline
0121: 31 58                 acall   print_text
0123: 31 58                 acall   print_text
                   
                   ; the end
0125: 21 25                 ajmp    *
                   
                   test__text:
0127: 48 65 6C 6C 
      6F 2C 20 77 
      6F 72 6C 64 
      21                    .byte   "Hello, world!"
                   test__newline:
0134: 0D 0A 00              .byte   13, 10, 0
                   test__space:
0137: 20 00                 .byte   32, 0
                   
                   ; *********************
                   ; * Library Functions *
                   ; *********************
                   
                   ; *** serial/init.inc ***
                   
                   ; >> void serial_init() <<
                   
                   ; Initialize serial interface.
                   ; - assumes 20MHz clock and X2 mode
                   ; - uses internal baud rate generator
                   ; - speed: 9600 bits per second
                   ; Formula: BRL = 256 - (F_clk / (32 * Baud_Rate))
                   ; ---
                   ; See datasheet page 52 for details,
                   ; also note oscillator diagram on page 16!
                   
                   serial_init:
0139: 75 98 52              mov     SCON,   #0x52   ; SM1, REN, TI
013C: 75 9A BF              mov     BRL,    #191    ; 9600 @20MHz CLK
013F: 75 9B 1E              mov     BDRCON, #0x1e   ; BRR, RBCK, TBCK, SPD
0142: 22                    ret
                   
                   ; *** serial/rx.inc ***
                   
                   ; >> char serial_rx <<
                   
                   ; Receive byte into accumulator.
                   
                   serial_rx:
0143: 30 98 FD              jnb     RI,     serial_rx
0146: C2 98                 clr     RI
0148: E5 99                 mov     a,      SBUF
014A: 22                    ret
                   
                   ; *** serial/tx.inc ***
                   
                   ; >> void serial_tx(char a) <<
                   
                   ; Transmit byte from accumulator.
                   
                   serial_tx:
014B: 30 99 FD              jnb     TI,     serial_tx
014E: C2 99                 clr     TI
0150: F5 99                 mov     SBUF,   a
0152: 22                    ret
                   
                   ; *** print/char.inc ***
                   
                   ; >> void print_char(char a) <<
                   
                   ; Print char from accumulator.
                   ; Indirect call to function behind OUT pointer.
                   
                   print_char:
0153: C0 32                 push    OUT
0155: C0 33                 push    OUT+1
0157: 22                    ret
                   
                   ; *** print/text.inc ***
                   
                   ; >> void print_text(char* dptr) <<
                   
                   ; Print null-terminated string from program code.
                   ; Aborts if no null terminator is found after 256 bytes.
                   
                   print_text:
0158: C0 E0                 push    ACC
015A: E8                    mov     a,      r0
015B: C0 E0                 push    ACC
                   
015D: E4                    clr     a
015E: F8                    mov     r0,     a
                   print_text__loop:
015F: 93                    movc    a,      @dptr+a
0160: 60 06                 jz      print_text__end
0162: 31 53                 acall   print_char
0164: 08                    inc     r0
0165: E8                    mov     a,      r0
0166: 70 F7                 jnz     print_text__loop
                   
                   print_text__end:
0168: D0 E0                 pop     ACC
016A: F8                    mov     r0,     a
016B: D0 E0                 pop     ACC
016D: 22                    ret
                   
                   ; *** print/hex.inc ***
                   
                   ; >> void print_hex_8(char a) <<
                   
                   ; Print hexadecimal number from accumulator.
                   
                   print_hex_8:
016E: C4                    swap    a       ; high nibble first
016F: 31 72                 acall   print_hex_8__nibble
0171: C4                    swap    a
                   print_hex_8__nibble:
0172: C0 E0                 push    ACC
0174: 54 0F                 anl     a,      #0x0f
0176: 24 90                 add     a,      #0x90
0178: D4                    da      a
0179: 34 40                 addc    a,      #0x40
017B: D4                    da      a
017C: 44 20                 orl     a,      #0x20   ; lower case
017E: 31 53                 acall   print_char
0180: D0 E0                 pop     ACC
0182: 22                    ret
                   
                   ; >> void print_hex_16(int r0r1) <<
                   
                   ; Print hexadecimal number from r0-r1.
                   
                   print_hex_16:
0183: C0 E0                 push    ACC
0185: E9                    mov     a,      r1      ; MSB first
0186: 31 6E                 acall   print_hex_8
0188: E8                    mov     a,      r0      ; LSB second
0189: 31 6E                 acall   print_hex_8
018B: D0 E0                 pop     ACC
018D: 22                    ret
                   
                   ; >> void print_hex_32(long r0r1r2r3) <<
                   
                   ; Print hexadecimal number from r0-r3.
                   
                   print_hex_32:
018E: C0 E0                 push    ACC
0190: EB                    mov     a,      r3      ; MSB first
0191: 31 6E                 acall   print_hex_8
0193: EA                    mov     a,      r2
0194: 31 6E                 acall   print_hex_8
0196: E9                    mov     a,      r1
0197: 31 6E                 acall   print_hex_8
0199: E8                    mov     a,      r0      ; LSB last
019A: 31 6E                 acall   print_hex_8
019C: D0 E0                 pop     ACC
019E: 22                    ret
                   
                   ; *** print/int.inc ***
                   
                   ; >> void print_int_s8(char a) <<
                   
                   ; Print signed integer from accumulator.
                   
                   print_int_s8:
019F: C0 E0                 push    ACC
01A1: C0 F0                 push    B
01A3: 30 E7 10              jnb     ACC.7,  print_int_u8__1
01A6: F5 F0                 mov     b,      a
01A8: 74 2D                 mov     a,      #'-'
01AA: 31 53                 acall   print_char
01AC: E5 F0                 mov     a,      b
01AE: F4                    cpl     a
01AF: 04                    inc     a
01B0: 80 04                 sjmp    print_int_u8__1
                   
                   ; >> void print_int_u8(char a) <<
                   
                   ; Print unsingned integer from accumulator.
                   
                   print_int_u8:
01B2: C0 E0                 push    ACC
01B4: C0 F0                 push    B
                   print_int_u8__1:
01B6: 88 F0                 mov     b,      r0
01B8: C0 F0                 push    B
                   
01BA: 78 00                 mov     r0,     #0
01BC: 75 F0 64              mov     b,      #100
01BF: 84                    div     ab
01C0: 60 05                 jz      print_int_u8__tens
01C2: 24 30                 add     a,      #'0'
01C4: 31 53                 acall   print_char
01C6: 08                    inc     r0      ; stop skipping leading zeroes
                   print_int_u8__tens:
01C7: E5 F0                 mov     a,      b
01C9: 75 F0 0A              mov     b,      #10
01CC: 84                    div     ab
01CD: 28                    add     a,      r0
01CE: 60 05                 jz      print_int_u8__ones
01D0: 98                    subb    a,      r0
01D1: 24 30                 add     a,      #'0'
01D3: 31 53                 acall   print_char
                   print_int_u8__ones:
01D5: E5 F0                 mov     a,      b
01D7: 24 30                 add     a,      #'0'
01D9: 31 53                 acall   print_char
                   
01DB: D0 E0                 pop     ACC
01DD: F8                    mov     r0,     a
01DE: D0 F0                 pop     B
01E0: D0 E0                 pop     ACC
01E2: 22                    ret
                   
                   ; >> void print_int_s16(int r0r1) <<
                   
                   ; Print signed integer from r0-r1.
                   
                   print_int_s16:
01E3: C0 E0                 push    ACC
01E5: E8                    mov     a,      r0
01E6: C0 E0                 push    ACC
01E8: E9                    mov     a,      r1
01E9: C0 E0                 push    ACC
01EB: 30 E7 18              jnb     ACC.7,  print_int_u16__1
01EE: 74 2D                 mov     a,      #'-'
01F0: 31 53                 acall   print_char
01F2: E8                    mov     a,      r0
01F3: F4                    cpl     a
01F4: 24 01                 add     a,      #1
01F6: F8                    mov     r0,     a
01F7: E9                    mov     a,      r1
01F8: F4                    cpl     a
01F9: 34 00                 addc    a,      #0
01FB: F9                    mov     r1,     a
01FC: 80 08                 sjmp    print_int_u16__1
                   
                   
                   ; >> void print_int_u16(int r0r1) <<
                   
                   ; Print unsigned integer from r0-r1.
                   
                   print_int_u16:
01FE: C0 E0                 push    ACC
0200: E8                    mov     a,      r0
0201: C0 E0                 push    ACC
0203: E9                    mov     a,      r1
0204: C0 E0                 push    ACC
                   print_int_u16__1:
0206: EB                    mov     a,      r3
0207: C0 E0                 push    ACC
0209: C0 F0                 push    B
                   
020B: 7A 00                 mov     r2,     #0 ; flag for leading zeroes
                   
                            ; divide by 10000 (0x2710)
                            ; collect quotient in b
020D: 75 F0 FF              mov     b,      #-1
0210: C3                    clr     c
                   print_int_u16__10k_loop:
0211: E8                    mov     a,      r0
0212: 94 10                 subb    a,      #0x10
0214: F8                    mov     r0,     a
0215: E9                    mov     a,      r1
0216: 94 27                 subb    a,      #0x27
0218: F9                    mov     r1,     a
0219: 05 F0                 inc     b
021B: 50 F4                 jnc     print_int_u16__10k_loop
                            ; undo last subtraction to restore remainder
021D: E8                    mov     a,      r0
021E: 24 10                 add     a,      #0x10
0220: F8                    mov     r0,     a
0221: E9                    mov     a,      r1
0222: 34 27                 addc    a,      #0x27
0224: F9                    mov     r1,     a
                            ; print tenthousands digit
0225: E5 F0                 mov     a,      b
0227: 60 05                 jz      print_int_u16__1k
0229: 24 30                 add     a,      #'0'
022B: 31 53                 acall   print_char
022D: 0A                    inc     r2
                   print_int_u16__1k:
                            ; divide by 1000 (0x03e8)
                            ; collect quotient in b
022E: 75 F0 FF              mov     b,      #-1
0231: C3                    clr     c
                   print_int_u16__1k_loop:
0232: E8                    mov     a,      r0
0233: 94 E8                 subb    a,      #0xe8
0235: F8                    mov     r0,     a
0236: E9                    mov     a,      r1
0237: 94 03                 subb    a,      #0x03
0239: F9                    mov     r1,     a
023A: 05 F0                 inc     b
023C: 50 F4                 jnc     print_int_u16__1k_loop
                            ; undo last subtraction to restore remainder
023E: E8                    mov     a,      r0
023F: 24 E8                 add     a,      #0xe8
0241: F8                    mov     r0,     a
0242: E9                    mov     a,      r1
0243: 34 03                 addc    a,      #0x03
0245: F9                    mov     r1,     a
                            ; print thousands digit
0246: E5 F0                 mov     a,      b
0248: 2A                    add     a,      r2
0249: 60 06                 jz      print_int_u16__100
024B: 9A                    subb    a,      r2
024C: 24 30                 add     a,      #'0'
024E: 31 53                 acall   print_char
0250: 0A                    inc     r2
                   print_int_u16__100:
                            ; divide by 100 (0x0064)
                            ; collect quotient in b
0251: 75 F0 FF              mov     b,      #-1
0254: C3                    clr     c
                   print_int_u16__100_loop:
0255: E8                    mov     a,      r0
0256: 94 64                 subb    a,      #0x64
0258: F8                    mov     r0,     a
0259: E9                    mov     a,      r1
025A: 94 00                 subb    a,      #0x00
025C: F9                    mov     r1,     a
025D: 05 F0                 inc     b
025F: 50 F4                 jnc     print_int_u16__100_loop
                            ; undo last subtraction to restore remainder
0261: E8                    mov     a,      r0
0262: 24 64                 add     a,      #0x64
0264: F8                    mov     r0,     a
0265: E9                    mov     a,      r1
0266: 34 00                 addc    a,      #0x00
0268: F9                    mov     r1,     a
                            ; print hundreds digit
0269: E5 F0                 mov     a,      b
026B: 2A                    add     a,      r2
026C: 60 06                 jz      print_int_u16__tens
026E: 9A                    subb    a,      r2
026F: 24 30                 add     a,      #'0'
0271: 31 53                 acall   print_char
0273: 0A                    inc     r2
                   print_int_u16__tens:
                            ; divde by 10 (using div instruction)
0274: E8                    mov     a,      r0
0275: 75 F0 0A              mov     b,      #10
0278: 84                    div     ab
                            ; print tens digit
0279: 2A                    add     a,      r2
027A: 60 05                 jz      print_int_u16__ones
027C: 9A                    subb    a,      r2
027D: 24 30                 add     a,      #'0'
027F: 31 53                 acall   print_char
                   print_int_u16__ones:
                            ; print ones digit
0281: E5 F0                 mov     a,      b
0283: 24 30                 add     a,      #'0'
0285: 31 53                 acall   print_char
                   
0287: D0 F0                 pop     B
0289: D0 E0                 pop     ACC
028B: FA                    mov     r2,     a
028C: D0 E0                 pop     ACC
028E: F9                    mov     r1,     a
028F: D0 E0                 pop     ACC
0291: F8                    mov     r0,     a
0292: D0 E0                 pop     ACC
0294: 22                    ret
