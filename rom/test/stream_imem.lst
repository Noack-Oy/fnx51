                   
                   ; ******************************
                   ; * Memory Stream Test Program *
                   ; ******************************
                   
                   ; This program wtites and reads internal memory through a st
                   
                   
                   ; **********************
                   ; * Header Definitions *
                   ; **********************
                   
                   ; *** global/variables.equ ***
                   
                   ; variables in internal RAM
                   
                   ; 0x00-0x1f: register banks 0-3
                   ; 0x20-0x2f: bit addressable variables
                   
0000:              .equ    in,             0x30    ; pointer to input handling 
0000:              .equ    out,            0x32    ; pointer to ouput handling 
                   
0000:              .equ    stream_in,      0x34    ; input stream position
0000:              .equ    stream_out,     0x36    ; output stream position
                   
0000:              .equ    memory_list,    0x38    ; pointer to heap list head
0000:              .equ    memory_start,   0x40    ; first allocatable address
0000:              .equ    memory_end,     0x42    ; last allocatable address
                   
0000:              .equ    block_read,     0x44    ; pointers to block device d
0000:              .equ    block_write,    0x46    ; code (read and write funct
0000:              .equ    block_cache,    0x48    ; pointer to block cache dat
                   
0000:              .equ    fatfs_info,     0x50    ; pointer to FAT file system
                   
0000:              .equ    stack,          0x60    ; beginning of stack (grows 
                   
                   ; *** serial/sfr.equ ***
                   
                   ; Special function registers for serial interface.
                   ; See chapter 14 of AT89C51ED2 datasheet, page 48ff.
                   
                   ; Internal Baud Rate Generator (BRG), see datasheet page 52.
0000:                      .equ    BRL,    0x9A    ; baud rate reload value
0000:                      .equ    BDRCON, 0x9B    ; BRG control register
                   
                   
                   ; *************
                   ; * Main Code *
                   ; *************
                   
0000:              .org 0
                   
                   ; *** global/init.inc ***
                   
                   ; Initialize stack pointer and global variables.
                   ; This must be included early in the main program.
                   
                   global_init:
0000: 75 81 60             mov     SP,#STACK
                   
                   ; Select register bank zero, clear processor flags
0003: 75 D0 00             mov     PSW,#0
                   
                   ; Fill internal RAM with markers for uninitialized data
0006: 78 00                mov     r0,#0 ; write pointer
                   
0008: 74 3F                mov     a,#0x3f ; '?' for uninitialized registers
                   global_init__1:
000A: 08                   inc     r0 ; first iteration skips address 0, r0 liv
000B: F6                   mov     @r0,a
000C: B8 1F FB             cjne    r0,#0x1f,global_init__1
                   
000F: 74 2A                mov     a,#0x2a ; '*' for uninitialized variables
                   global_init__2:
0011: 08                   inc     r0
0012: F6                   mov     @r0,a
0013: B8 5F FB             cjne    r0,#STACK-1,global_init__2
                   
0016: 74 7E                mov     a,#0x7e ; '~' for stack and above
                   global_init__3:
0018: 08                   inc     r0
0019: F6                   mov     @r0,a
001A: B8 FF FB             cjne    r0,#0xff,global_init__3
                   
                   ; *** test/stream.asm ***
                   
001D: 11 72                acall   serial_init
                   
001F:              .equ    scratch,        0xa0
                   
001F: C0 32                push    out
0021: C0 33                push    out+1
0023: 90 00 A9             mov     dptr,   #stream_imem_write
0026: 85 82 32             mov     out,    dpl
0029: 85 83 33             mov     out+1,  dph
002C: 75 36 A0             mov     stream_out,     #scratch
002F: 90 00 55             mov     dptr,   #test_message
0032: 11 B9                acall   print_text
0034: E5 36                mov     a,      stream_out
0036: 31 13                acall   print_int_u8
0038: A8 36                mov     r0,     stream_out
003A: 74 FF                mov     a,      #0xff
003C: F6                   mov     @r0,    a
003D: D0 33                pop     out+1
003F: D0 32                pop     out
                   
0041: E4                   clr     a
0042: FB                   mov     r3,     a
0043: FA                   mov     r2,     a
0044: F9                   mov     r1,     a
0045: F8                   mov     r0,     a
0046: F5 34                mov     stream_in,      a
0048: 90 00 9E             mov     dptr,   #stream_imem_read
004B: 85 82 30             mov     in,     dpl
004E: 85 83 31             mov     in+1,   dph
0051: 51 C4                acall   dump
                   
0053: 80 FE                sjmp    *
                   
                   test_message:
0055: 48 65 6C 6C 
      6F 20 66 72 
      6F 6D 20 69 
      6E 74 65 72 
      6E 61 6C 20 
      6D 65 6D 6F 
      72 79 3A 20 
                           .db     "Hello from internal memory: "
                   test_message_end:
0071: 00                   .db     0
                   
                   
                   ; *********************
                   ; * Library Functions *
                   ; *********************
                   
                   ; *** serial/init.inc ***
                   
                   ; >> void serial_init() <<
                   
                   ; Initialize serial interface.
                   ; - assumes 20MHz clock and X2 mode
                   ; - uses internal baud rate generator
                   ; - speed: 9600 bits per second
                   ; Formula: BRL = 256 - (F_clk / (32 * Baud_Rate))
                   ; ---
                   ; See datasheet page 52 for details,
                   ; also note oscillator diagram on page 16!
                   
                   serial_init:
0072: 75 98 52             mov     SCON,   #0x52   ; SM1, REN, TI
0075: 75 9A BF             mov     BRL,    #191    ; 9600 @20MHz CLK
0078: 75 9B 1E             mov     BDRCON, #0x1e   ; BRR, RBCK, TBCK, SPD
                   
007B: 90 00 8E             mov     dptr,   #serial_rx
007E: 85 82 30             mov     IN,     DPL
0081: 85 83 31             mov     IN+1,   DPH
                   
0084: 90 00 96             mov     dptr,   #serial_tx
0087: 85 82 32             mov     OUT,    DPL
008A: 85 83 33             mov     OUT+1,  DPH
                   
008D: 22                   ret
                   
                   ; *** serial/rx.inc ***
                   
                   ; >> char serial_rx <<
                   
                   ; Receive byte into accumulator.
                   
                   serial_rx:
008E: 30 98 FD             jnb     RI,     serial_rx
0091: C2 98                clr     RI
0093: E5 99                mov     a,      SBUF
0095: 22                   ret
                   
                   ; *** serial/tx.inc ***
                   
                   ; >> void serial_tx(char a) <<
                   
                   ; Transmit byte from accumulator.
                   
                   serial_tx:
0096: 30 99 FD             jnb     TI,     serial_tx
0099: C2 99                clr     TI
009B: F5 99                mov     SBUF,   a
009D: 22                   ret
                   
                   ; *** stream/imem_read.inc ***
                   
                   ; >> char stream_imem_read() <<
                   
                   ; Read byte from internal RAM at stream input pointer.
                   ; Only the lower byte of the stream pointer is used and incr
                   
                   stream_imem_read:
009E: C8                   xch     a,      r0
009F: C5 34                xch     a,      stream_in
00A1: C8                   xch     a,      r0
00A2: E6                   mov     a,      @r0
00A3: 08                   inc     r0
00A4: C8                   xch     a,      r0
00A5: C5 34                xch     a,      stream_in
00A7: C8                   xch     a,      r0
00A8: 22                   ret
                   
                   ; *** stream/imem_write.inc ***
                   
                   ; >> void stream_imem_write(char a) <<
                   
                   ; Write byte to internal RAM at stream output pointer.
                   ; Only the lower byte of the stream pointer is used and incr
                   
                   stream_imem_write:
00A9: C8                   xch     a,      r0
00AA: C5 36                xch     a,      stream_out
00AC: C8                   xch     a,      r0
00AD: F6                   mov     @r0,    a
00AE: 08                   inc     r0
00AF: C8                   xch     a,      r0
00B0: C5 36                xch     a,      stream_out
00B2: C8                   xch     a,      r0
00B3: 22                   ret
                   
                   ; *** print/char.inc ***
                   
                   ; >> void print_char(char a) <<
                   
                   ; Print char from accumulator.
                   ; Indirect call to function behind OUT pointer.
                   
                   print_char:
00B4: C0 32                push    OUT
00B6: C0 33                push    OUT+1
00B8: 22                   ret
                   
                   ; *** print/text.inc ***
                   
                   ; >> void print_text(char* dptr) <<
                   
                   ; Print null-terminated string from program code.
                   ; Aborts if no null terminator is found after 256 bytes.
                   
                   print_text:
00B9: C0 E0                push    ACC
00BB: E8                   mov     a,      r0
00BC: C0 E0                push    ACC
                   
00BE: E4                   clr     a
00BF: F8                   mov     r0,     a
                   print_text__loop:
00C0: 93                   movc    a,      @dptr+a
00C1: 60 06                jz      print_text__end
00C3: 11 B4                acall   print_char
00C5: 08                   inc     r0
00C6: E8                   mov     a,      r0
00C7: 70 F7                jnz     print_text__loop
                   
                   print_text__end:
00C9: D0 E0                pop     ACC
00CB: F8                   mov     r0,     a
00CC: D0 E0                pop     ACC
00CE: 22                   ret
                   
                   ; *** print/hex.inc ***
                   
                   ; >> void print_hex_8(char a) <<
                   
                   ; Print hexadecimal number from accumulator.
                   
                   print_hex_8:
00CF: C4                   swap    a       ; high nibble first
00D0: 11 D3                acall   print_hex_8__nibble
00D2: C4                   swap    a
                   print_hex_8__nibble:
00D3: C0 E0                push    ACC
00D5: 54 0F                anl     a,      #0x0f
00D7: 24 90                add     a,      #0x90
00D9: D4                   da      a
00DA: 34 40                addc    a,      #0x40
00DC: D4                   da      a
00DD: 44 20                orl     a,      #0x20   ; lower case
00DF: 11 B4                acall   print_char
00E1: D0 E0                pop     ACC
00E3: 22                   ret
                   
                   ; >> void print_hex_16(int r0r1) <<
                   
                   ; Print hexadecimal number from r0-r1.
                   
                   print_hex_16:
00E4: C0 E0                push    ACC
00E6: E9                   mov     a,      r1      ; MSB first
00E7: 11 CF                acall   print_hex_8
00E9: E8                   mov     a,      r0      ; LSB second
00EA: 11 CF                acall   print_hex_8
00EC: D0 E0                pop     ACC
00EE: 22                   ret
                   
                   ; >> void print_hex_32(long r0r1r2r3) <<
                   
                   ; Print hexadecimal number from r0-r3.
                   
                   print_hex_32:
00EF: C0 E0                push    ACC
00F1: EB                   mov     a,      r3      ; MSB first
00F2: 11 CF                acall   print_hex_8
00F4: EA                   mov     a,      r2
00F5: 11 CF                acall   print_hex_8
00F7: E9                   mov     a,      r1
00F8: 11 CF                acall   print_hex_8
00FA: E8                   mov     a,      r0      ; LSB last
00FB: 11 CF                acall   print_hex_8
00FD: D0 E0                pop     ACC
00FF: 22                   ret
                   
                   ; *** print/int.inc ***
                   
                   ; >> void print_int_s8(char a) <<
                   
                   ; Print signed integer from accumulator.
                   
                   print_int_s8:
0100: C0 E0                push    ACC
0102: C0 F0                push    B
0104: 30 E7 10             jnb     ACC.7,  print_int_u8__1
0107: F5 F0                mov     b,      a
0109: 74 2D                mov     a,      #'-'
010B: 11 B4                acall   print_char
010D: E5 F0                mov     a,      b
010F: F4                   cpl     a
0110: 04                   inc     a
0111: 80 04                sjmp    print_int_u8__1
                   
                   ; >> void print_int_u8(char a) <<
                   
                   ; Print unsingned integer from accumulator.
                   
                   print_int_u8:
0113: C0 E0                push    ACC
0115: C0 F0                push    B
                   print_int_u8__1:
0117: 88 F0                mov     b,      r0
0119: C0 F0                push    B
                   
011B: 78 00                mov     r0,     #0
011D: 75 F0 64             mov     b,      #100
0120: 84                   div     ab
0121: 60 05                jz      print_int_u8__tens
0123: 24 30                add     a,      #'0'
0125: 11 B4                acall   print_char
0127: 08                   inc     r0      ; stop skipping leading zeroes
                   print_int_u8__tens:
0128: E5 F0                mov     a,      b
012A: 75 F0 0A             mov     b,      #10
012D: 84                   div     ab
012E: 28                   add     a,      r0
012F: 60 05                jz      print_int_u8__ones
0131: 98                   subb    a,      r0
0132: 24 30                add     a,      #'0'
0134: 11 B4                acall   print_char
                   print_int_u8__ones:
0136: E5 F0                mov     a,      b
0138: 24 30                add     a,      #'0'
013A: 11 B4                acall   print_char
                   
013C: D0 E0                pop     ACC
013E: F8                   mov     r0,     a
013F: D0 F0                pop     B
0141: D0 E0                pop     ACC
0143: 22                   ret
                   
                   ; >> void print_int_s16(int r0r1) <<
                   
                   ; Print signed integer from r0-r1.
                   
                   print_int_s16:
0144: C0 E0                push    ACC
0146: E8                   mov     a,      r0
0147: C0 E0                push    ACC
0149: E9                   mov     a,      r1
014A: C0 E0                push    ACC
014C: 30 E7 18             jnb     ACC.7,  print_int_u16__1
014F: 74 2D                mov     a,      #'-'
0151: 11 B4                acall   print_char
0153: E8                   mov     a,      r0
0154: F4                   cpl     a
0155: 24 01                add     a,      #1
0157: F8                   mov     r0,     a
0158: E9                   mov     a,      r1
0159: F4                   cpl     a
015A: 34 00                addc    a,      #0
015C: F9                   mov     r1,     a
015D: 80 08                sjmp    print_int_u16__1
                   
                   ; >> void print_int_u16(int r0r1) <<
                   
                   ; Print unsigned integer from r0-r1.
                   
                   print_int_u16:
015F: C0 E0                push    ACC
0161: E8                   mov     a,      r0
0162: C0 E0                push    ACC
0164: E9                   mov     a,      r1
0165: C0 E0                push    ACC
                   print_int_u16__1:
0167: EB                   mov     a,      r3
0168: C0 E0                push    ACC
016A: C0 F0                push    B
                   
016C: 7A 00                mov     r2,     #0 ; flag for leading zeroes
                   
                           ; divide by 10000 (0x2710)
                           ; collect quotient in b
016E: 75 F0 FF             mov     b,      #-1
0171: C3                   clr     c
                   print_int_u16__10k_loop:
0172: E8                   mov     a,      r0
0173: 94 10                subb    a,      #0x10
0175: F8                   mov     r0,     a
0176: E9                   mov     a,      r1
0177: 94 27                subb    a,      #0x27
0179: F9                   mov     r1,     a
017A: 05 F0                inc     b
017C: 50 F4                jnc     print_int_u16__10k_loop
                           ; undo last subtraction to restore remainder
017E: E8                   mov     a,      r0
017F: 24 10                add     a,      #0x10
0181: F8                   mov     r0,     a
0182: E9                   mov     a,      r1
0183: 34 27                addc    a,      #0x27
0185: F9                   mov     r1,     a
                           ; print tenthousands digit
0186: E5 F0                mov     a,      b
0188: 60 05                jz      print_int_u16__1k
018A: 24 30                add     a,      #'0'
018C: 11 B4                acall   print_char
018E: 0A                   inc     r2
                   print_int_u16__1k:
                           ; divide by 1000 (0x03e8)
                           ; collect quotient in b
018F: 75 F0 FF             mov     b,      #-1
0192: C3                   clr     c
                   print_int_u16__1k_loop:
0193: E8                   mov     a,      r0
0194: 94 E8                subb    a,      #0xe8
0196: F8                   mov     r0,     a
0197: E9                   mov     a,      r1
0198: 94 03                subb    a,      #0x03
019A: F9                   mov     r1,     a
019B: 05 F0                inc     b
019D: 50 F4                jnc     print_int_u16__1k_loop
                           ; undo last subtraction to restore remainder
019F: E8                   mov     a,      r0
01A0: 24 E8                add     a,      #0xe8
01A2: F8                   mov     r0,     a
01A3: E9                   mov     a,      r1
01A4: 34 03                addc    a,      #0x03
01A6: F9                   mov     r1,     a
                           ; print thousands digit
01A7: E5 F0                mov     a,      b
01A9: 2A                   add     a,      r2
01AA: 60 06                jz      print_int_u16__100
01AC: 9A                   subb    a,      r2
01AD: 24 30                add     a,      #'0'
01AF: 11 B4                acall   print_char
01B1: 0A                   inc     r2
                   print_int_u16__100:
                           ; divide by 100 (0x0064)
                           ; collect quotient in b
01B2: 75 F0 FF             mov     b,      #-1
01B5: C3                   clr     c
                   print_int_u16__100_loop:
01B6: E8                   mov     a,      r0
01B7: 94 64                subb    a,      #0x64
01B9: F8                   mov     r0,     a
01BA: E9                   mov     a,      r1
01BB: 94 00                subb    a,      #0x00
01BD: F9                   mov     r1,     a
01BE: 05 F0                inc     b
01C0: 50 F4                jnc     print_int_u16__100_loop
                           ; undo last subtraction to restore remainder
01C2: E8                   mov     a,      r0
01C3: 24 64                add     a,      #0x64
01C5: F8                   mov     r0,     a
01C6: E9                   mov     a,      r1
01C7: 34 00                addc    a,      #0x00
01C9: F9                   mov     r1,     a
                           ; print hundreds digit
01CA: E5 F0                mov     a,      b
01CC: 2A                   add     a,      r2
01CD: 60 06                jz      print_int_u16__tens
01CF: 9A                   subb    a,      r2
01D0: 24 30                add     a,      #'0'
01D2: 11 B4                acall   print_char
01D4: 0A                   inc     r2
                   print_int_u16__tens:
                           ; divide by 10 (using div instruction)
01D5: E8                   mov     a,      r0
01D6: 75 F0 0A             mov     b,      #10
01D9: 84                   div     ab
                           ; print tens digit
01DA: 2A                   add     a,      r2
01DB: 60 05                jz      print_int_u16__ones
01DD: 9A                   subb    a,      r2
01DE: 24 30                add     a,      #'0'
01E0: 11 B4                acall   print_char
                   print_int_u16__ones:
                           ; print ones digit
01E2: E5 F0                mov     a,      b
01E4: 24 30                add     a,      #'0'
01E6: 11 B4                acall   print_char
                   
01E8: D0 F0                pop     B
01EA: D0 E0                pop     ACC
01EC: FA                   mov     r2,     a
01ED: D0 E0                pop     ACC
01EF: F9                   mov     r1,     a
01F0: D0 E0                pop     ACC
01F2: F8                   mov     r0,     a
01F3: D0 E0                pop     ACC
01F5: 22                   ret
                   
                   ; >> void print_int_s32(long r0r1r2r3) <<
                   
                   ; Print signed integer from r0-r3.
                   
                   print_int_s32:
01F6: C0 E0                push    acc
01F8: C0 F0                push    b
01FA: C0 82                push    dpl
01FC: C0 83                push    dph
01FE: 71 8D                acall   regbank_next
                           ; r4-r7: value to print
0200: E6                   mov     a,      @r0
0201: FC                   mov     r4,     a
0202: 08                   inc     r0
0203: E6                   mov     a,      @r0
0204: FD                   mov     r5,     a
0205: 08                   inc     r0
0206: E6                   mov     a,      @r0
0207: FE                   mov     r6,     a
0208: 08                   inc     r0
0209: E6                   mov     a,      @r0
020A: FF                   mov     r7,     a
020B: 30 E7 2F             jnb     ACC.7,  print_int_u32__1
020E: 74 2D                mov     a,      #'-'
0210: 11 B4                acall   print_char
0212: EC                   mov     a,      r4
0213: F4                   cpl     a
0214: 24 01                add     a,      #1
0216: FC                   mov     r4,     a
0217: ED                   mov     a,      r5
0218: F4                   cpl     a
0219: 34 00                addc    a,      #0
021B: FD                   mov     r5,     a
021C: EE                   mov     a,      r6
021D: F4                   cpl     a
021E: 34 00                addc    a,      #0
0220: FE                   mov     r6,     a
0221: EF                   mov     a,      r7
0222: F4                   cpl     a
0223: 34 00                addc    a,      #0
0225: FF                   mov     r7,     a
0226: 80 15                sjmp    print_int_u32__1
                   
                   
                   ; >> void print_int_u32(long r0r1r2r3) <<
                   
                   ; Print unsigned integer from r0-r3.
                   
                   print_int_u32:
0228: C0 E0                push    acc
022A: C0 F0                push    b
022C: C0 82                push    dpl
022E: C0 83                push    dph
0230: 71 8D                acall   regbank_next
                           ; r4-r7: value to print
0232: E6                   mov     a,      @r0
0233: FC                   mov     r4,     a
0234: 08                   inc     r0
0235: E6                   mov     a,      @r0
0236: FD                   mov     r5,     a
0237: 08                   inc     r0
0238: E6                   mov     a,      @r0
0239: FE                   mov     r6,     a
023A: 08                   inc     r0
023B: E6                   mov     a,      @r0
023C: FF                   mov     r7,     a
                   print_int_u32__1:
023D: 75 F0 00             mov     b,      #0 ; flag for leading zeroes
0240: 90 02 74             mov     dptr,   #print_int_u32__divisors
                   print_int_u32__loop:
                           ; get divisor
0243: E4                   clr     a
0244: 93                   movc    a,      @a+dptr
0245: F8                   mov     r0,     a
0246: A3                   inc     dptr
0247: E4                   clr     a
0248: 93                   movc    a,      @a+dptr
0249: F9                   mov     r1,     a
024A: A3                   inc     dptr
024B: E4                   clr     a
024C: 93                   movc    a,      @a+dptr
024D: FA                   mov     r2,     a
024E: A3                   inc     dptr
024F: E4                   clr     a
0250: 93                   movc    a,      @a+dptr
0251: FB                   mov     r3,     a
0252: A3                   inc     dptr
                           ; divide r4-r7 by r0-r3
0253: 51 98                acall   print_int_u32__divide
0255: 25 F0                add     a,      b
0257: 60 08                jz      print_int_u32__skip ; leading zero
0259: 95 F0                subb    a,      b
025B: 24 30                add     a,      #'0'
025D: 05 F0                inc     b
025F: 11 B4                acall   print_char
                   print_int_u32__skip:
0261: B8 0A DF             cjne    r0,     #0x0a,  print_int_u32__loop
0264: EC                   mov     a,      r4
0265: 24 30                add     a,      #'0'
0267: 11 B4                acall   print_char
                   
0269: 71 A6                acall   regbank_prev
026B: D0 83                pop     dph
026D: D0 82                pop     dpl
026F: D0 F0                pop     b
0271: D0 E0                pop     acc
0273: 22                   ret
                   ; Divisor table:
                   print_int_u32__divisors:
                           ; 1,000,000,000 = 3b9aca00
0274: 00 CA 9A 3B 
                           .db     0x00, 0xca, 0x9a, 0x3b
                           ;   100,000,000 = 05f5e100
0278: 00 E1 F5 05 
                           .db     0x00, 0xe1, 0xf5, 0x05
                           ;    10,000,000 = 00989680
027C: 80 96 98 00 
                           .db     0x80, 0x96, 0x98, 0x00
                           ;     1,000,000 = 000f4240
0280: 40 42 0F 00 
                           .db     0x40, 0x42, 0x0f, 0x00
                           ;       100,000 = 000186a0
0284: A0 86 01 00 
                           .db     0xa0, 0x86, 0x01, 0x00
                           ;        10,000 = 00002710
0288: 10 27 00 00 
                           .db     0x10, 0x27, 0x00, 0x00
                           ;         1,000 = 000003e8
028C: E8 03 00 00 
                           .db     0xe8, 0x03, 0x00, 0x00
                           ;           100 = 00000064
0290: 64 00 00 00 
                           .db     0x64, 0x00, 0x00, 0x00
                           ;            10 = 0000000a
0294: 0A 00 00 00 
                           .db     0x0a, 0x00, 0x00, 0x00
                   ; Divide r4-r7 by r0-r1 using repeated subtraction.
                   ; Quotient returned in a, remainder in r4-r7.
                   ; Since the quotient is at most 9,
                   ; this is faster than 'proper' division.
                   print_int_u32__divide:
0298: C0 F0                push    b
029A: C3                   clr     c
029B: 75 F0 FF             mov     b,      #-1
                   print_int_u32__divide_loop:
029E: EC                   mov     a,      r4
029F: 98                   subb    a,      r0
02A0: FC                   mov     r4,     a
02A1: ED                   mov     a,      r5
02A2: 99                   subb    a,      r1
02A3: FD                   mov     r5,     a
02A4: EE                   mov     a,      r6
02A5: 9A                   subb    a,      r2
02A6: FE                   mov     r6,     a
02A7: EF                   mov     a,      r7
02A8: 9B                   subb    a,      r3
02A9: FF                   mov     r7,     a
02AA: 05 F0                inc     b
02AC: 50 F0                jnc     print_int_u32__divide_loop
                           ; restore remainder
02AE: EC                   mov     a,      r4
02AF: 28                   add     a,      r0
02B0: FC                   mov     r4,     a
02B1: ED                   mov     a,      r5
02B2: 39                   addc    a,      r1
02B3: FD                   mov     r5,     a
02B4: EE                   mov     a,      r6
02B5: 3A                   addc    a,      r2
02B6: FE                   mov     r6,     a
02B7: EF                   mov     a,      r7
02B8: 3B                   addc    a,      r3
02B9: FF                   mov     r7,     a
02BA: E5 F0                mov     a,      b
02BC: D0 F0                pop     b
02BE: 22                   ret
                   
                   ; *** read/char.inc ***
                   
                   ; >> char read_char() <<
                   
                   ; Read char into accumulator.
                   ; Indirect call to function behind IN pointer.
                   
                   read_char:
02BF: C0 30                push    IN
02C1: C0 31                push    IN+1
02C3: 22                   ret
                   
                   ; *** util/dump.inc ***
                   
                   ; >> uint32{r0-r3} dump(uint32{r0-r3} addr, uint8{a} count) 
                   
                   ; Print hexdump from standard input to standard output.
                   ; Starting value for address column in r0-r3.
                   ; Number of bytes to print in a (0 means 256).
                   ; r0-r3 contains next address upon exit.
                   
                   dump:
02C4: C0 F0                push    b
02C6: C0 E0                push    acc
02C8: F5 F0                mov     b,      a
02CA: EC                   mov     a,      r4
02CB: C0 E0                push    acc
02CD: ED                   mov     a,      r5
02CE: C0 E0                push    acc
02D0: EE                   mov     a,      r6
02D1: C0 E0                push    acc
02D3: EF                   mov     a,      r7
02D4: C0 E0                push    acc
                   
                           ; b: total bytes remaining
                           ; r0: buffer pointer
                           ; r1: read loop counter / padding size
                           ; r2: print loop counter
                   
                           ; r4-7: address label
02D6: 71 80                acall   xch_r0123_r4567
                   
                           ; allocate 16 byte array on stack
02D8: E5 81                mov     a,      sp
02DA: F8                   mov     r0,     a
02DB: 24 10                add     a,      #16
02DD: F5 81                mov     sp,     a
                   
                   dump__line_loop:
                           ; read into buffer
02DF: 79 10                mov     r1,     #16
                   dump__read_loop:
02E1: 51 BF                acall   read_char
02E3: 08                   inc     r0
02E4: F6                   mov     @r0,    a
02E5: D5 F0 03             djnz    b,      dump__read_continue
02E8: 19                   dec     r1
02E9: 80 02                sjmp    dump__read_end
                   dump__read_continue:
02EB: D9 F4                djnz    r1,     dump__read_loop
                   dump__read_end:
                   
                           ; print address column
02ED: 71 80                acall   xch_r0123_r4567
02EF: 11 EF                acall   print_hex_32
02F1: 71 80                acall   xch_r0123_r4567
02F3: 74 3A                mov     a,      #':'
02F5: 11 B4                acall   print_char
                   
                           ; if r1 is nonzero here, we have a shorter line
                           ; the value in r1 is the number of padding bytes
                   
                           ; wind back pointer
02F7: E8                   mov     a,      r0
02F8: 24 F0                add     a,      #-16
02FA: 29                   add     a,      r1
02FB: F8                   mov     r0,     a
                   
                           ; print hex
02FC: 7A 10                mov     r2,     #16
                   dump__print_hex_loop:
02FE: 08                   inc     r0
02FF: EA                   mov     a,      r2
0300: 54 03                anl     a,      #3      ; mod 4
0302: 70 04                jnz     dump__print_hex_no_gap
0304: 74 20                mov     a,      #' ' ; gap after every 4 bytes
0306: 11 B4                acall   print_char
                   dump__print_hex_no_gap:
0308: EA                   mov     a,      r2
0309: D3                   setb    c
030A: 99                   subb    a,      r1
030B: 50 08                jnc     dump__print_hex_no_padding
030D: 74 20                mov     a,      #' ' ; padding for shorter line
030F: 11 B4                acall   print_char
0311: 11 B4                acall   print_char
0313: 80 03                sjmp    dump__print_hex_next
                   dump__print_hex_no_padding:
0315: E6                   mov     a,      @r0
0316: 11 CF                acall   print_hex_8
                   dump__print_hex_next:
0318: 74 20                mov     a,      #' ' ; space between bytes
031A: 11 B4                acall   print_char
031C: DA E0                djnz    r2,     dump__print_hex_loop
                   
                           ; wind back again
031E: E8                   mov     a,      r0
031F: 24 F0                add     a,      #-16
0321: F8                   mov     r0,     a
                   
                           ; print ascii
0322: 74 20                mov     a,      #' '
0324: 11 B4                acall   print_char
0326: 74 7C                mov     a,      #'|'
0328: 11 B4                acall   print_char
032A: 74 10                mov     a,      #16
032C: C3                   clr     c
032D: 99                   subb    a,      r1
032E: F9                   mov     r1,     a ; number of bytes to print
032F: FA                   mov     r2,     a
                   dump__print_ascii_loop:
0330: 08                   inc     r0
0331: E6                   mov     a,      @r0
0332: B4 20 00             cjne    a,      #0x20,  dump__print_ascii_check1
                   dump__print_ascii_check1:
0335: 40 05                jc      dump__print_ascii_replace
0337: B4 7F 00             cjne    a,      #0x7f,  dump__print_ascii_check2
                   dump__print_ascii_check2:
033A: 40 02                jc      dump__print_ascii_continue
                   dump__print_ascii_replace:
033C: 74 2E                mov     a,      #'.'
                   dump__print_ascii_continue:
033E: 11 B4                acall   print_char
0340: DA EE                djnz    r2,     dump__print_ascii_loop
0342: 74 7C                mov     a,      #'|'
0344: 11 B4                acall   print_char
0346: 74 0D                mov     a,      #13
0348: 11 B4                acall   print_char
034A: 74 0A                mov     a,      #10
034C: 11 B4                acall   print_char
                   
                           ; wind back again
034E: E8                   mov     a,      r0
034F: 24 F0                add     a,      #-16
0351: F8                   mov     r0,     a
                   
                           ; next address
0352: EC                   mov     a,      r4
0353: 29                   add     a,      r1
0354: FC                   mov     r4,     a
0355: ED                   mov     a,      r5
0356: 34 00                addc    a,      #0
0358: FD                   mov     r5,     a
0359: EE                   mov     a,      r6
035A: 34 00                addc    a,      #0
035C: FE                   mov     r6,     a
035D: EF                   mov     a,      r7
035E: 34 00                addc    a,      #0
0360: FF                   mov     r7,     a
                   
0361: E5 F0                mov     a,      b
0363: 60 02                jz      dump__end
0365: 41 DF                ajmp    dump__line_loop
                   
                   dump__end:
                           ; deallocate array from stack
0367: E5 81                mov     a,      sp
0369: 24 F0                add     a,      #-16
036B: F5 81                mov     sp,     a
                   
036D: 71 80                acall   xch_r0123_r4567
                   
036F: D0 E0                pop     acc
0371: FF                   mov     r7,     a
0372: D0 E0                pop     acc
0374: FE                   mov     r6,     a
0375: D0 E0                pop     acc
0377: FD                   mov     r5,     a
0378: D0 E0                pop     acc
037A: FC                   mov     r4,     a
037B: D0 E0                pop     acc
037D: D0 F0                pop     b
037F: 22                   ret
                   
                   ; *** util/xch.inc ***
                   
                   ; >> void xch_r0123_r4567(uint32 &r0r1r2r3, uint32 &r4r5r6r7
                   
                   ; Exchange registers r0-r3 with r4-r7.
                   
                   xch_r0123_r4567:
                           ; r0 <-> r4
0380: C8                   xch     a,      r0
0381: CC                   xch     a,      r4
0382: C8                   xch     a,      r0
                           ; r1 <-> r5
0383: C9                   xch     a,      r1
0384: CD                   xch     a,      r5
0385: C9                   xch     a,      r1
                           ; r2 <-> r6
0386: CA                   xch     a,      r2
0387: CE                   xch     a,      r6
0388: CA                   xch     a,      r2
                           ; r3 <-> r7
0389: CB                   xch     a,      r3
038A: CF                   xch     a,      r7
038B: CB                   xch     a,      r3
                           ; a remains unchanged
038C: 22                   ret
                   
                   ; *** util/regbank.inc ***
                   
                   ; >> void*{r0} regbank_next() <<
                   
                   ; Switch to next register bank.
                   ; Return pointer to r0 of old bank in new r0.
                   
                   regbank_next:
038D: C0 E0                push    acc
                           ; check if already at highest bank
038F: E5 D0                mov     a,      psw
0391: 54 18                anl     a,      #0x18   ; mask off rs0 and rs1
0393: B4 18 02             cjne    a,      #0x18,  regbank_next__continue
0396: 71 B9                acall   panic   ; overflow
                   regbank_next__continue:
                           ; switch to next bank
0398: E5 D0                mov     a,      psw
039A: 24 08                add     a,      #0x08
039C: F5 D0                mov     psw,    a
                           ; calculate pointer to old bank
039E: 54 18                anl     a,      #0x18
03A0: 24 F8                add     a,      #0xf8 ; subtract 8
03A2: F8                   mov     r0,     a
                           ; done
03A3: D0 E0                pop     acc
03A5: 22                   ret
                   
                   ; >> void regbank_prev() <<
                   
                   ; Switch to previous register bank.
                   
                   regbank_prev:
03A6: C0 E0                push    acc
                           ; check if already at lowest bank
03A8: E5 D0                mov     a,      psw
03AA: 54 18                anl     a,      #0x18
03AC: 70 02                jnz     regbank_prev__continue
03AE: 71 B9                acall   panic   ; underflow
                   regbank_prev__continue:
                           ; switch to previous bank
03B0: E5 D0                mov     a,      psw
03B2: 24 F8                add     a,      #0xf8 ; subtract 8
03B4: F5 D0                mov     psw,    a
                           ; done
03B6: D0 E0                pop     acc
03B8: 22                   ret
                   
03B9:              .equ panic_out, serial_tx
                   
                   ; *** panic/panic.inc ***
                   
                   ; >> void panic() <<
                   
                   ; Unrecoverable error handler.
                   ; Print caller address and halt.
                   
                   panic:
03B9: C2 AF                clr     ea      ; disable interrupts
03BB: F8                   mov     r0,a
03BC: 90 00 96             mov     dptr,#panic_out
03BF: 85 82 32             mov     out,dpl
03C2: 85 83 33             mov     out+1,dph
03C5: 90 03 E3             mov     dptr,#panic_text
03C8: 11 B9                acall   print_text
03CA: D0 E0                pop     acc
03CC: 11 CF                acall   print_hex_8
03CE: D0 E0                pop     acc
03D0: 11 CF                acall   print_hex_8
03D2: 74 20                mov     a,#' '
03D4: 11 B4                acall   print_char
03D6: E8                   mov     a,r0
03D7: 11 CF                acall   print_hex_8
03D9: 74 0D                mov     a,#13
03DB: 11 B4                acall   print_char
03DD: 74 0A                mov     a,#10
03DF: 11 B4                acall   print_char
03E1: 80 FE                sjmp    *
                   
                   panic_text:
03E3: 0D 0A                .db     13, 10
03E5: 20 21 21 21 
      20 70 61 6E 
      69 63 20 40 
                           .db     " !!! panic @"
03F1: 00                   .db     0
