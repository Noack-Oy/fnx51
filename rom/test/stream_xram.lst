                   
                   ; ****************************
                   ; * XRAM Stream Test Program *
                   ; ****************************
                   
                   ; This program wtites and reads XRAM through a stream
                   
                   
                   ; **********************
                   ; * Header Definitions *
                   ; **********************
                   
                   ; *** global/variables.equ ***
                   
                   ; variables in internal RAM
                   
                   ; 0x00-0x1f: register banks 0-3
                   ; 0x20-0x2f: bit addressable variables
                   
0000:              .equ    in,             0x30    ; pointer to input handling 
0000:              .equ    out,            0x32    ; pointer to ouput handling 
                   
0000:              .equ    stream_in,      0x34    ; input stream position
0000:              .equ    stream_out,     0x36    ; output stream position
                   
0000:              .equ    memory_list,    0x38    ; pointer to heap list head
0000:              .equ    memory_start,   0x40    ; first allocatable address
0000:              .equ    memory_end,     0x42    ; last allocatable address
                   
0000:              .equ    block_read,     0x44    ; pointers to block device d
0000:              .equ    block_write,    0x46    ; code (read and write funct
0000:              .equ    block_cache,    0x48    ; pointer to block cache dat
                   
0000:              .equ    fatfs_info,     0x50    ; pointer to FAT file system
                   
0000:              .equ    stack,          0x60    ; beginning of stack (grows 
                   
                   ; *** global/sfr.equ ***
                   
                   ; global SFRs
                   
0000:              .equ    auxr,   0x8e    ; auxiliary register 0
0000:              .equ    auxr1,  0xa2    ; auxiliary register 1
                   
                   ; *** serial/sfr.equ ***
                   
                   ; Special function registers for serial interface.
                   ; See chapter 14 of AT89C51ED2 datasheet, page 48ff.
                   
                   ; Internal Baud Rate Generator (BRG), see datasheet page 52.
0000:                      .equ    BRL,    0x9A    ; baud rate reload value
0000:                      .equ    BDRCON, 0x9B    ; BRG control register
                   
                   
                   ; *************
                   ; * Main Code *
                   ; *************
                   
0000:              .org 0
                   
                   ; *** global/init.inc ***
                   
                   ; Initialize stack pointer and global variables.
                   ; This must be included early in the main program.
                   
                   global_init:
0000: 75 81 60             mov     SP,#STACK
                   
                   ; Select register bank zero, clear processor flags
0003: 75 D0 00             mov     PSW,#0
                   
                   ; Fill internal RAM with markers for uninitialized data
0006: 78 00                mov     r0,#0 ; write pointer
                   
0008: 74 3F                mov     a,#0x3f ; '?' for uninitialized registers
                   global_init__1:
000A: 08                   inc     r0 ; first iteration skips address 0, r0 liv
000B: F6                   mov     @r0,a
000C: B8 1F FB             cjne    r0,#0x1f,global_init__1
                   
000F: 74 2A                mov     a,#0x2a ; '*' for uninitialized variables
                   global_init__2:
0011: 08                   inc     r0
0012: F6                   mov     @r0,a
0013: B8 5F FB             cjne    r0,#STACK-1,global_init__2
                   
0016: 74 7E                mov     a,#0x7e ; '~' for stack and above
                   global_init__3:
0018: 08                   inc     r0
0019: F6                   mov     @r0,a
001A: B8 FF FB             cjne    r0,#0xff,global_init__3
                   
                   ; *** test/stream_xram.asm ***
                   
001D: 11 6A                acall   serial_init
                   
001F:              .equ    scratch,        0x180
                   
001F: C0 32                push    out
0021: C0 33                push    out+1
0023: 90 00 B7             mov     dptr,   #stream_xram_write
0026: 85 82 32             mov     out,    dpl
0029: 85 83 33             mov     out+1,  dph
002C: 90 01 80             mov     dptr,   #scratch
002F: 85 82 36             mov     stream_out,     dpl
0032: 85 83 37             mov     stream_out+1,   dph
0035: 90 00 5C             mov     dptr,   #test_message
0038: 11 DD                acall   print_text
003A: A8 36                mov     r0,     stream_out
003C: A9 37                mov     r1,     stream_out+1
003E: 31 83                acall   print_int_u16
0040: D0 33                pop     out+1
0042: D0 32                pop     out
                   
0044: E4                   clr     a
0045: FB                   mov     r3,     a
0046: FA                   mov     r2,     a
0047: F9                   mov     r1,     a
0048: F8                   mov     r0,     a
0049: F5 34                mov     stream_in,      a
004B: F5 35                mov     stream_in+1,    a
004D: 90 00 96             mov     dptr,   #stream_xram_read
0050: 85 82 30             mov     in,     dpl
0053: 85 83 31             mov     in+1,   dph
0056: 51 E8                acall   dump
0058: 51 E8                acall   dump
                   
005A: 80 FE                sjmp    *
                   
                   test_message:
005C: 48 65 6C 6C 
      6F 2C 20 58 
      52 41 4D 3A 
      20                   .db     "Hello, XRAM: "
                   test_message_end:
0069: 00                   .db     0
                   
                   
                   ; *********************
                   ; * Library Functions *
                   ; *********************
                   
                   ; *** serial/init.inc ***
                   
                   ; >> void serial_init() <<
                   
                   ; Initialize serial interface.
                   ; - assumes 20MHz clock and X2 mode
                   ; - uses internal baud rate generator
                   ; - speed: 9600 bits per second
                   ; Formula: BRL = 256 - (F_clk / (32 * Baud_Rate))
                   ; ---
                   ; See datasheet page 52 for details,
                   ; also note oscillator diagram on page 16!
                   
                   serial_init:
006A: 75 98 52             mov     SCON,   #0x52   ; SM1, REN, TI
006D: 75 9A BF             mov     BRL,    #191    ; 9600 @20MHz CLK
0070: 75 9B 1E             mov     BDRCON, #0x1e   ; BRR, RBCK, TBCK, SPD
                   
0073: 90 00 86             mov     dptr,   #serial_rx
0076: 85 82 30             mov     IN,     DPL
0079: 85 83 31             mov     IN+1,   DPH
                   
007C: 90 00 8E             mov     dptr,   #serial_tx
007F: 85 82 32             mov     OUT,    DPL
0082: 85 83 33             mov     OUT+1,  DPH
                   
0085: 22                   ret
                   
                   ; *** serial/rx.inc ***
                   
                   ; >> char serial_rx <<
                   
                   ; Receive byte into accumulator.
                   
                   serial_rx:
0086: 30 98 FD             jnb     RI,     serial_rx
0089: C2 98                clr     RI
008B: E5 99                mov     a,      SBUF
008D: 22                   ret
                   
                   ; *** serial/tx.inc ***
                   
                   ; >> void serial_tx(char a) <<
                   
                   ; Transmit byte from accumulator.
                   
                   serial_tx:
008E: 30 99 FD             jnb     TI,     serial_tx
0091: C2 99                clr     TI
0093: F5 99                mov     SBUF,   a
0095: 22                   ret
                   
                   ; *** stream/xram_read.inc ***
                   
                   ; >> char{a} stream_xram_read() <<
                   
                   ; Read byte from on-chip expanded RAM at stream input pointe
                   ; 16 bit value of the stream pointer is used and incremented
                   
                   stream_xram_read:
0096: C0 8E                push    auxr
0098: C0 82                push    dpl
009A: C0 83                push    dph
                   
009C: 53 8E E1             anl     auxr,#0xe1      ; clear extram, xrs0-2
009F: 43 8E 10             orl     auxr,#0x10      ; set xrs2 (size 1792 bytes)
                   
00A2: 85 34 82             mov     dpl,stream_in
00A5: 85 35 83             mov     dph,stream_in+1
                   
00A8: E0                   movx    a,@dptr
00A9: A3                   inc     dptr
00AA: 85 82 34             mov     stream_in,dpl
00AD: 85 83 35             mov     stream_in+1,dph
                   
00B0: D0 83                pop     dph
00B2: D0 82                pop     dpl
00B4: D0 8E                pop     auxr
00B6: 22                   ret
                   
                   ; *** stream/xram_write.inc ***
                   
                   ; >> void stream_xram_write(char a) <<
                   
                   ; Write byte to on-chip expanded RAM at stream output pointe
                   ; 16-bit value of the stream pointer is used and incremented
                   
                   stream_xram_write:
00B7: C0 8E                push    auxr
00B9: C0 82                push    dpl
00BB: C0 83                push    dph
                   
00BD: 53 8E E1             anl     auxr,#0xe1      ; clear extram, xrs0-2
00C0: 43 8E 10             orl     auxr,#0x10      ; set xrs2 (size 1792 bytes)
                   
00C3: 85 36 82             mov     dpl,stream_out
00C6: 85 37 83             mov     dph,stream_out+1
                   
00C9: F0                   movx    @dptr,a
00CA: A3                   inc     dptr
00CB: 85 82 36             mov     stream_out,dpl
00CE: 85 83 37             mov     stream_out+1,dph
                   
00D1: D0 83                pop     dph
00D3: D0 82                pop     dpl
00D5: D0 8E                pop     auxr
00D7: 22                   ret
                   
                   ; *** print/char.inc ***
                   
                   ; >> void print_char(char a) <<
                   
                   ; Print char from accumulator.
                   ; Indirect call to function behind OUT pointer.
                   
                   print_char:
00D8: C0 32                push    OUT
00DA: C0 33                push    OUT+1
00DC: 22                   ret
                   
                   ; *** print/text.inc ***
                   
                   ; >> void print_text(char* dptr) <<
                   
                   ; Print null-terminated string from program code.
                   ; Aborts if no null terminator is found after 256 bytes.
                   
                   print_text:
00DD: C0 E0                push    ACC
00DF: E8                   mov     a,      r0
00E0: C0 E0                push    ACC
                   
00E2: E4                   clr     a
00E3: F8                   mov     r0,     a
                   print_text__loop:
00E4: 93                   movc    a,      @dptr+a
00E5: 60 06                jz      print_text__end
00E7: 11 D8                acall   print_char
00E9: 08                   inc     r0
00EA: E8                   mov     a,      r0
00EB: 70 F7                jnz     print_text__loop
                   
                   print_text__end:
00ED: D0 E0                pop     ACC
00EF: F8                   mov     r0,     a
00F0: D0 E0                pop     ACC
00F2: 22                   ret
                   
                   ; *** print/hex.inc ***
                   
                   ; >> void print_hex_8(char a) <<
                   
                   ; Print hexadecimal number from accumulator.
                   
                   print_hex_8:
00F3: C4                   swap    a       ; high nibble first
00F4: 11 F7                acall   print_hex_8__nibble
00F6: C4                   swap    a
                   print_hex_8__nibble:
00F7: C0 E0                push    ACC
00F9: 54 0F                anl     a,      #0x0f
00FB: 24 90                add     a,      #0x90
00FD: D4                   da      a
00FE: 34 40                addc    a,      #0x40
0100: D4                   da      a
0101: 44 20                orl     a,      #0x20   ; lower case
0103: 11 D8                acall   print_char
0105: D0 E0                pop     ACC
0107: 22                   ret
                   
                   ; >> void print_hex_16(int r0r1) <<
                   
                   ; Print hexadecimal number from r0-r1.
                   
                   print_hex_16:
0108: C0 E0                push    ACC
010A: E9                   mov     a,      r1      ; MSB first
010B: 11 F3                acall   print_hex_8
010D: E8                   mov     a,      r0      ; LSB second
010E: 11 F3                acall   print_hex_8
0110: D0 E0                pop     ACC
0112: 22                   ret
                   
                   ; >> void print_hex_32(long r0r1r2r3) <<
                   
                   ; Print hexadecimal number from r0-r3.
                   
                   print_hex_32:
0113: C0 E0                push    ACC
0115: EB                   mov     a,      r3      ; MSB first
0116: 11 F3                acall   print_hex_8
0118: EA                   mov     a,      r2
0119: 11 F3                acall   print_hex_8
011B: E9                   mov     a,      r1
011C: 11 F3                acall   print_hex_8
011E: E8                   mov     a,      r0      ; LSB last
011F: 11 F3                acall   print_hex_8
0121: D0 E0                pop     ACC
0123: 22                   ret
                   
                   ; *** print/int.inc ***
                   
                   ; >> void print_int_s8(char a) <<
                   
                   ; Print signed integer from accumulator.
                   
                   print_int_s8:
0124: C0 E0                push    ACC
0126: C0 F0                push    B
0128: 30 E7 10             jnb     ACC.7,  print_int_u8__1
012B: F5 F0                mov     b,      a
012D: 74 2D                mov     a,      #'-'
012F: 11 D8                acall   print_char
0131: E5 F0                mov     a,      b
0133: F4                   cpl     a
0134: 04                   inc     a
0135: 80 04                sjmp    print_int_u8__1
                   
                   ; >> void print_int_u8(char a) <<
                   
                   ; Print unsingned integer from accumulator.
                   
                   print_int_u8:
0137: C0 E0                push    ACC
0139: C0 F0                push    B
                   print_int_u8__1:
013B: 88 F0                mov     b,      r0
013D: C0 F0                push    B
                   
013F: 78 00                mov     r0,     #0
0141: 75 F0 64             mov     b,      #100
0144: 84                   div     ab
0145: 60 05                jz      print_int_u8__tens
0147: 24 30                add     a,      #'0'
0149: 11 D8                acall   print_char
014B: 08                   inc     r0      ; stop skipping leading zeroes
                   print_int_u8__tens:
014C: E5 F0                mov     a,      b
014E: 75 F0 0A             mov     b,      #10
0151: 84                   div     ab
0152: 28                   add     a,      r0
0153: 60 05                jz      print_int_u8__ones
0155: 98                   subb    a,      r0
0156: 24 30                add     a,      #'0'
0158: 11 D8                acall   print_char
                   print_int_u8__ones:
015A: E5 F0                mov     a,      b
015C: 24 30                add     a,      #'0'
015E: 11 D8                acall   print_char
                   
0160: D0 E0                pop     ACC
0162: F8                   mov     r0,     a
0163: D0 F0                pop     B
0165: D0 E0                pop     ACC
0167: 22                   ret
                   
                   ; >> void print_int_s16(int r0r1) <<
                   
                   ; Print signed integer from r0-r1.
                   
                   print_int_s16:
0168: C0 E0                push    ACC
016A: E8                   mov     a,      r0
016B: C0 E0                push    ACC
016D: E9                   mov     a,      r1
016E: C0 E0                push    ACC
0170: 30 E7 18             jnb     ACC.7,  print_int_u16__1
0173: 74 2D                mov     a,      #'-'
0175: 11 D8                acall   print_char
0177: E8                   mov     a,      r0
0178: F4                   cpl     a
0179: 24 01                add     a,      #1
017B: F8                   mov     r0,     a
017C: E9                   mov     a,      r1
017D: F4                   cpl     a
017E: 34 00                addc    a,      #0
0180: F9                   mov     r1,     a
0181: 80 08                sjmp    print_int_u16__1
                   
                   ; >> void print_int_u16(int r0r1) <<
                   
                   ; Print unsigned integer from r0-r1.
                   
                   print_int_u16:
0183: C0 E0                push    ACC
0185: E8                   mov     a,      r0
0186: C0 E0                push    ACC
0188: E9                   mov     a,      r1
0189: C0 E0                push    ACC
                   print_int_u16__1:
018B: EB                   mov     a,      r3
018C: C0 E0                push    ACC
018E: C0 F0                push    B
                   
0190: 7A 00                mov     r2,     #0 ; flag for leading zeroes
                   
                           ; divide by 10000 (0x2710)
                           ; collect quotient in b
0192: 75 F0 FF             mov     b,      #-1
0195: C3                   clr     c
                   print_int_u16__10k_loop:
0196: E8                   mov     a,      r0
0197: 94 10                subb    a,      #0x10
0199: F8                   mov     r0,     a
019A: E9                   mov     a,      r1
019B: 94 27                subb    a,      #0x27
019D: F9                   mov     r1,     a
019E: 05 F0                inc     b
01A0: 50 F4                jnc     print_int_u16__10k_loop
                           ; undo last subtraction to restore remainder
01A2: E8                   mov     a,      r0
01A3: 24 10                add     a,      #0x10
01A5: F8                   mov     r0,     a
01A6: E9                   mov     a,      r1
01A7: 34 27                addc    a,      #0x27
01A9: F9                   mov     r1,     a
                           ; print tenthousands digit
01AA: E5 F0                mov     a,      b
01AC: 60 05                jz      print_int_u16__1k
01AE: 24 30                add     a,      #'0'
01B0: 11 D8                acall   print_char
01B2: 0A                   inc     r2
                   print_int_u16__1k:
                           ; divide by 1000 (0x03e8)
                           ; collect quotient in b
01B3: 75 F0 FF             mov     b,      #-1
01B6: C3                   clr     c
                   print_int_u16__1k_loop:
01B7: E8                   mov     a,      r0
01B8: 94 E8                subb    a,      #0xe8
01BA: F8                   mov     r0,     a
01BB: E9                   mov     a,      r1
01BC: 94 03                subb    a,      #0x03
01BE: F9                   mov     r1,     a
01BF: 05 F0                inc     b
01C1: 50 F4                jnc     print_int_u16__1k_loop
                           ; undo last subtraction to restore remainder
01C3: E8                   mov     a,      r0
01C4: 24 E8                add     a,      #0xe8
01C6: F8                   mov     r0,     a
01C7: E9                   mov     a,      r1
01C8: 34 03                addc    a,      #0x03
01CA: F9                   mov     r1,     a
                           ; print thousands digit
01CB: E5 F0                mov     a,      b
01CD: 2A                   add     a,      r2
01CE: 60 06                jz      print_int_u16__100
01D0: 9A                   subb    a,      r2
01D1: 24 30                add     a,      #'0'
01D3: 11 D8                acall   print_char
01D5: 0A                   inc     r2
                   print_int_u16__100:
                           ; divide by 100 (0x0064)
                           ; collect quotient in b
01D6: 75 F0 FF             mov     b,      #-1
01D9: C3                   clr     c
                   print_int_u16__100_loop:
01DA: E8                   mov     a,      r0
01DB: 94 64                subb    a,      #0x64
01DD: F8                   mov     r0,     a
01DE: E9                   mov     a,      r1
01DF: 94 00                subb    a,      #0x00
01E1: F9                   mov     r1,     a
01E2: 05 F0                inc     b
01E4: 50 F4                jnc     print_int_u16__100_loop
                           ; undo last subtraction to restore remainder
01E6: E8                   mov     a,      r0
01E7: 24 64                add     a,      #0x64
01E9: F8                   mov     r0,     a
01EA: E9                   mov     a,      r1
01EB: 34 00                addc    a,      #0x00
01ED: F9                   mov     r1,     a
                           ; print hundreds digit
01EE: E5 F0                mov     a,      b
01F0: 2A                   add     a,      r2
01F1: 60 06                jz      print_int_u16__tens
01F3: 9A                   subb    a,      r2
01F4: 24 30                add     a,      #'0'
01F6: 11 D8                acall   print_char
01F8: 0A                   inc     r2
                   print_int_u16__tens:
                           ; divide by 10 (using div instruction)
01F9: E8                   mov     a,      r0
01FA: 75 F0 0A             mov     b,      #10
01FD: 84                   div     ab
                           ; print tens digit
01FE: 2A                   add     a,      r2
01FF: 60 05                jz      print_int_u16__ones
0201: 9A                   subb    a,      r2
0202: 24 30                add     a,      #'0'
0204: 11 D8                acall   print_char
                   print_int_u16__ones:
                           ; print ones digit
0206: E5 F0                mov     a,      b
0208: 24 30                add     a,      #'0'
020A: 11 D8                acall   print_char
                   
020C: D0 F0                pop     B
020E: D0 E0                pop     ACC
0210: FA                   mov     r2,     a
0211: D0 E0                pop     ACC
0213: F9                   mov     r1,     a
0214: D0 E0                pop     ACC
0216: F8                   mov     r0,     a
0217: D0 E0                pop     ACC
0219: 22                   ret
                   
                   ; >> void print_int_s32(long r0r1r2r3) <<
                   
                   ; Print signed integer from r0-r3.
                   
                   print_int_s32:
021A: C0 E0                push    acc
021C: C0 F0                push    b
021E: C0 82                push    dpl
0220: C0 83                push    dph
0222: 71 B1                acall   regbank_next
                           ; r4-r7: value to print
0224: E6                   mov     a,      @r0
0225: FC                   mov     r4,     a
0226: 08                   inc     r0
0227: E6                   mov     a,      @r0
0228: FD                   mov     r5,     a
0229: 08                   inc     r0
022A: E6                   mov     a,      @r0
022B: FE                   mov     r6,     a
022C: 08                   inc     r0
022D: E6                   mov     a,      @r0
022E: FF                   mov     r7,     a
022F: 30 E7 2F             jnb     ACC.7,  print_int_u32__1
0232: 74 2D                mov     a,      #'-'
0234: 11 D8                acall   print_char
0236: EC                   mov     a,      r4
0237: F4                   cpl     a
0238: 24 01                add     a,      #1
023A: FC                   mov     r4,     a
023B: ED                   mov     a,      r5
023C: F4                   cpl     a
023D: 34 00                addc    a,      #0
023F: FD                   mov     r5,     a
0240: EE                   mov     a,      r6
0241: F4                   cpl     a
0242: 34 00                addc    a,      #0
0244: FE                   mov     r6,     a
0245: EF                   mov     a,      r7
0246: F4                   cpl     a
0247: 34 00                addc    a,      #0
0249: FF                   mov     r7,     a
024A: 80 15                sjmp    print_int_u32__1
                   
                   
                   ; >> void print_int_u32(long r0r1r2r3) <<
                   
                   ; Print unsigned integer from r0-r3.
                   
                   print_int_u32:
024C: C0 E0                push    acc
024E: C0 F0                push    b
0250: C0 82                push    dpl
0252: C0 83                push    dph
0254: 71 B1                acall   regbank_next
                           ; r4-r7: value to print
0256: E6                   mov     a,      @r0
0257: FC                   mov     r4,     a
0258: 08                   inc     r0
0259: E6                   mov     a,      @r0
025A: FD                   mov     r5,     a
025B: 08                   inc     r0
025C: E6                   mov     a,      @r0
025D: FE                   mov     r6,     a
025E: 08                   inc     r0
025F: E6                   mov     a,      @r0
0260: FF                   mov     r7,     a
                   print_int_u32__1:
0261: 75 F0 00             mov     b,      #0 ; flag for leading zeroes
0264: 90 02 98             mov     dptr,   #print_int_u32__divisors
                   print_int_u32__loop:
                           ; get divisor
0267: E4                   clr     a
0268: 93                   movc    a,      @a+dptr
0269: F8                   mov     r0,     a
026A: A3                   inc     dptr
026B: E4                   clr     a
026C: 93                   movc    a,      @a+dptr
026D: F9                   mov     r1,     a
026E: A3                   inc     dptr
026F: E4                   clr     a
0270: 93                   movc    a,      @a+dptr
0271: FA                   mov     r2,     a
0272: A3                   inc     dptr
0273: E4                   clr     a
0274: 93                   movc    a,      @a+dptr
0275: FB                   mov     r3,     a
0276: A3                   inc     dptr
                           ; divide r4-r7 by r0-r3
0277: 51 BC                acall   print_int_u32__divide
0279: 25 F0                add     a,      b
027B: 60 08                jz      print_int_u32__skip ; leading zero
027D: 95 F0                subb    a,      b
027F: 24 30                add     a,      #'0'
0281: 05 F0                inc     b
0283: 11 D8                acall   print_char
                   print_int_u32__skip:
0285: B8 0A DF             cjne    r0,     #0x0a,  print_int_u32__loop
0288: EC                   mov     a,      r4
0289: 24 30                add     a,      #'0'
028B: 11 D8                acall   print_char
                   
028D: 71 CA                acall   regbank_prev
028F: D0 83                pop     dph
0291: D0 82                pop     dpl
0293: D0 F0                pop     b
0295: D0 E0                pop     acc
0297: 22                   ret
                   ; Divisor table:
                   print_int_u32__divisors:
                           ; 1,000,000,000 = 3b9aca00
0298: 00 CA 9A 3B 
                           .db     0x00, 0xca, 0x9a, 0x3b
                           ;   100,000,000 = 05f5e100
029C: 00 E1 F5 05 
                           .db     0x00, 0xe1, 0xf5, 0x05
                           ;    10,000,000 = 00989680
02A0: 80 96 98 00 
                           .db     0x80, 0x96, 0x98, 0x00
                           ;     1,000,000 = 000f4240
02A4: 40 42 0F 00 
                           .db     0x40, 0x42, 0x0f, 0x00
                           ;       100,000 = 000186a0
02A8: A0 86 01 00 
                           .db     0xa0, 0x86, 0x01, 0x00
                           ;        10,000 = 00002710
02AC: 10 27 00 00 
                           .db     0x10, 0x27, 0x00, 0x00
                           ;         1,000 = 000003e8
02B0: E8 03 00 00 
                           .db     0xe8, 0x03, 0x00, 0x00
                           ;           100 = 00000064
02B4: 64 00 00 00 
                           .db     0x64, 0x00, 0x00, 0x00
                           ;            10 = 0000000a
02B8: 0A 00 00 00 
                           .db     0x0a, 0x00, 0x00, 0x00
                   ; Divide r4-r7 by r0-r1 using repeated subtraction.
                   ; Quotient returned in a, remainder in r4-r7.
                   ; Since the quotient is at most 9,
                   ; this is faster than 'proper' division.
                   print_int_u32__divide:
02BC: C0 F0                push    b
02BE: C3                   clr     c
02BF: 75 F0 FF             mov     b,      #-1
                   print_int_u32__divide_loop:
02C2: EC                   mov     a,      r4
02C3: 98                   subb    a,      r0
02C4: FC                   mov     r4,     a
02C5: ED                   mov     a,      r5
02C6: 99                   subb    a,      r1
02C7: FD                   mov     r5,     a
02C8: EE                   mov     a,      r6
02C9: 9A                   subb    a,      r2
02CA: FE                   mov     r6,     a
02CB: EF                   mov     a,      r7
02CC: 9B                   subb    a,      r3
02CD: FF                   mov     r7,     a
02CE: 05 F0                inc     b
02D0: 50 F0                jnc     print_int_u32__divide_loop
                           ; restore remainder
02D2: EC                   mov     a,      r4
02D3: 28                   add     a,      r0
02D4: FC                   mov     r4,     a
02D5: ED                   mov     a,      r5
02D6: 39                   addc    a,      r1
02D7: FD                   mov     r5,     a
02D8: EE                   mov     a,      r6
02D9: 3A                   addc    a,      r2
02DA: FE                   mov     r6,     a
02DB: EF                   mov     a,      r7
02DC: 3B                   addc    a,      r3
02DD: FF                   mov     r7,     a
02DE: E5 F0                mov     a,      b
02E0: D0 F0                pop     b
02E2: 22                   ret
                   
                   ; *** read/char.inc ***
                   
                   ; >> char read_char() <<
                   
                   ; Read char into accumulator.
                   ; Indirect call to function behind IN pointer.
                   
                   read_char:
02E3: C0 30                push    IN
02E5: C0 31                push    IN+1
02E7: 22                   ret
                   
                   ; *** util/dump.inc ***
                   
                   ; >> uint32{r0-r3} dump(uint32{r0-r3} addr, uint8{a} count) 
                   
                   ; Print hexdump from standard input to standard output.
                   ; Starting value for address column in r0-r3.
                   ; Number of bytes to print in a (0 means 256).
                   ; r0-r3 contains next address upon exit.
                   
                   dump:
02E8: C0 F0                push    b
02EA: C0 E0                push    acc
02EC: F5 F0                mov     b,      a
02EE: EC                   mov     a,      r4
02EF: C0 E0                push    acc
02F1: ED                   mov     a,      r5
02F2: C0 E0                push    acc
02F4: EE                   mov     a,      r6
02F5: C0 E0                push    acc
02F7: EF                   mov     a,      r7
02F8: C0 E0                push    acc
                   
                           ; b: total bytes remaining
                           ; r0: buffer pointer
                           ; r1: read loop counter / padding size
                           ; r2: print loop counter
                   
                           ; r4-7: address label
02FA: 71 A4                acall   xch_r0123_r4567
                   
                           ; allocate 16 byte array on stack
02FC: E5 81                mov     a,      sp
02FE: F8                   mov     r0,     a
02FF: 24 10                add     a,      #16
0301: F5 81                mov     sp,     a
                   
                   dump__line_loop:
                           ; read into buffer
0303: 79 10                mov     r1,     #16
                   dump__read_loop:
0305: 51 E3                acall   read_char
0307: 08                   inc     r0
0308: F6                   mov     @r0,    a
0309: D5 F0 03             djnz    b,      dump__read_continue
030C: 19                   dec     r1
030D: 80 02                sjmp    dump__read_end
                   dump__read_continue:
030F: D9 F4                djnz    r1,     dump__read_loop
                   dump__read_end:
                   
                           ; print address column
0311: 71 A4                acall   xch_r0123_r4567
0313: 31 13                acall   print_hex_32
0315: 71 A4                acall   xch_r0123_r4567
0317: 74 3A                mov     a,      #':'
0319: 11 D8                acall   print_char
                   
                           ; if r1 is nonzero here, we have a shorter line
                           ; the value in r1 is the number of padding bytes
                   
                           ; wind back pointer
031B: E8                   mov     a,      r0
031C: 24 F0                add     a,      #-16
031E: 29                   add     a,      r1
031F: F8                   mov     r0,     a
                   
                           ; print hex
0320: 7A 10                mov     r2,     #16
                   dump__print_hex_loop:
0322: 08                   inc     r0
0323: EA                   mov     a,      r2
0324: 54 03                anl     a,      #3      ; mod 4
0326: 70 04                jnz     dump__print_hex_no_gap
0328: 74 20                mov     a,      #' ' ; gap after every 4 bytes
032A: 11 D8                acall   print_char
                   dump__print_hex_no_gap:
032C: EA                   mov     a,      r2
032D: D3                   setb    c
032E: 99                   subb    a,      r1
032F: 50 08                jnc     dump__print_hex_no_padding
0331: 74 20                mov     a,      #' ' ; padding for shorter line
0333: 11 D8                acall   print_char
0335: 11 D8                acall   print_char
0337: 80 03                sjmp    dump__print_hex_next
                   dump__print_hex_no_padding:
0339: E6                   mov     a,      @r0
033A: 11 F3                acall   print_hex_8
                   dump__print_hex_next:
033C: 74 20                mov     a,      #' ' ; space between bytes
033E: 11 D8                acall   print_char
0340: DA E0                djnz    r2,     dump__print_hex_loop
                   
                           ; wind back again
0342: E8                   mov     a,      r0
0343: 24 F0                add     a,      #-16
0345: F8                   mov     r0,     a
                   
                           ; print ascii
0346: 74 20                mov     a,      #' '
0348: 11 D8                acall   print_char
034A: 74 7C                mov     a,      #'|'
034C: 11 D8                acall   print_char
034E: 74 10                mov     a,      #16
0350: C3                   clr     c
0351: 99                   subb    a,      r1
0352: F9                   mov     r1,     a ; number of bytes to print
0353: FA                   mov     r2,     a
                   dump__print_ascii_loop:
0354: 08                   inc     r0
0355: E6                   mov     a,      @r0
0356: B4 20 00             cjne    a,      #0x20,  dump__print_ascii_check1
                   dump__print_ascii_check1:
0359: 40 05                jc      dump__print_ascii_replace
035B: B4 7F 00             cjne    a,      #0x7f,  dump__print_ascii_check2
                   dump__print_ascii_check2:
035E: 40 02                jc      dump__print_ascii_continue
                   dump__print_ascii_replace:
0360: 74 2E                mov     a,      #'.'
                   dump__print_ascii_continue:
0362: 11 D8                acall   print_char
0364: DA EE                djnz    r2,     dump__print_ascii_loop
0366: 74 7C                mov     a,      #'|'
0368: 11 D8                acall   print_char
036A: 74 0D                mov     a,      #13
036C: 11 D8                acall   print_char
036E: 74 0A                mov     a,      #10
0370: 11 D8                acall   print_char
                   
                           ; wind back again
0372: E8                   mov     a,      r0
0373: 24 F0                add     a,      #-16
0375: F8                   mov     r0,     a
                   
                           ; next address
0376: EC                   mov     a,      r4
0377: 29                   add     a,      r1
0378: FC                   mov     r4,     a
0379: ED                   mov     a,      r5
037A: 34 00                addc    a,      #0
037C: FD                   mov     r5,     a
037D: EE                   mov     a,      r6
037E: 34 00                addc    a,      #0
0380: FE                   mov     r6,     a
0381: EF                   mov     a,      r7
0382: 34 00                addc    a,      #0
0384: FF                   mov     r7,     a
                   
0385: E5 F0                mov     a,      b
0387: 60 02                jz      dump__end
0389: 61 03                ajmp    dump__line_loop
                   
                   dump__end:
                           ; deallocate array from stack
038B: E5 81                mov     a,      sp
038D: 24 F0                add     a,      #-16
038F: F5 81                mov     sp,     a
                   
0391: 71 A4                acall   xch_r0123_r4567
                   
0393: D0 E0                pop     acc
0395: FF                   mov     r7,     a
0396: D0 E0                pop     acc
0398: FE                   mov     r6,     a
0399: D0 E0                pop     acc
039B: FD                   mov     r5,     a
039C: D0 E0                pop     acc
039E: FC                   mov     r4,     a
039F: D0 E0                pop     acc
03A1: D0 F0                pop     b
03A3: 22                   ret
                   
                   ; *** util/xch.inc ***
                   
                   ; >> void xch_r0123_r4567(uint32 &r0r1r2r3, uint32 &r4r5r6r7
                   
                   ; Exchange registers r0-r3 with r4-r7.
                   
                   xch_r0123_r4567:
                           ; r0 <-> r4
03A4: C8                   xch     a,      r0
03A5: CC                   xch     a,      r4
03A6: C8                   xch     a,      r0
                           ; r1 <-> r5
03A7: C9                   xch     a,      r1
03A8: CD                   xch     a,      r5
03A9: C9                   xch     a,      r1
                           ; r2 <-> r6
03AA: CA                   xch     a,      r2
03AB: CE                   xch     a,      r6
03AC: CA                   xch     a,      r2
                           ; r3 <-> r7
03AD: CB                   xch     a,      r3
03AE: CF                   xch     a,      r7
03AF: CB                   xch     a,      r3
                           ; a remains unchanged
03B0: 22                   ret
                   
                   ; *** util/regbank.inc ***
                   
                   ; >> void* regbank_next() <<
                   
                   ; Switch to next register bank.
                   ; Return pointer to r0 of old bank in new r0.
                   
                   regbank_next:
03B1: C0 E0                push    acc
                           ; check if already at highest bank
03B3: E5 D0                mov     a,      psw
03B5: 54 18                anl     a,      #0x18
03B7: B4 18 02             cjne    a,      #0x18,  regbank_next__continue
03BA: 71 DD                acall   panic   ; overflow
                   regbank_next__continue:
                           ; switch to next bank
03BC: E5 D0                mov     a,      psw
03BE: 24 08                add     a,      #0x08
03C0: F5 D0                mov     psw,    a
                           ; calculate pointer to old bank
03C2: 54 18                anl     a,      #0x18
03C4: 24 F8                add     a,      #0xf8
03C6: F8                   mov     r0,     a
                           ; done
03C7: D0 E0                pop     acc
03C9: 22                   ret
                   
                   ; >> void regbank_prev() <<
                   
                   ; Switch to previous register bank.
                   
                   regbank_prev:
03CA: C0 E0                push    acc
                           ; check if already at lowest bank
03CC: E5 D0                mov     a,      psw
03CE: 54 18                anl     a,      #0x18
03D0: 70 02                jnz     regbank_prev__continue
03D2: 71 DD                acall   panic   ; underflow
                   regbank_prev__continue:
                           ; switch to previous bank
03D4: E5 D0                mov     a,      psw
03D6: 24 F8                add     a,      #0xf8
03D8: F5 D0                mov     psw,    a
                           ; done
03DA: D0 E0                pop     acc
03DC: 22                   ret
                   
03DD:              .equ panic_out, serial_tx
                   
                   ; *** panic/panic.inc ***
                   
                   ; >> void panic() <<
                   
                   ; Unrecoverable error handler.
                   ; Print caller address and halt.
                   
                   panic:
03DD: C2 AF                clr     ea      ; disable interrupts
03DF: F8                   mov     r0,a
03E0: 90 00 8E             mov     dptr,#panic_out
03E3: 85 82 32             mov     out,dpl
03E6: 85 83 33             mov     out+1,dph
03E9: 90 04 07             mov     dptr,#panic_text
03EC: 11 DD                acall   print_text
03EE: D0 E0                pop     acc
03F0: 11 F3                acall   print_hex_8
03F2: D0 E0                pop     acc
03F4: 11 F3                acall   print_hex_8
03F6: 74 20                mov     a,#' '
03F8: 11 D8                acall   print_char
03FA: E8                   mov     a,r0
03FB: 11 F3                acall   print_hex_8
03FD: 74 0D                mov     a,#13
03FF: 11 D8                acall   print_char
0401: 74 0A                mov     a,#10
0403: 11 D8                acall   print_char
0405: 80 FE                sjmp    *
                   
                   panic_text:
0407: 0D 0A                .db     13, 10
0409: 20 21 21 21 
      20 70 61 6E 
      69 63 20 40 
                           .db     " !!! panic @"
0415: 00                   .db     0
