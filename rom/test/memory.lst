                   
                   ; ************************************
                   ; * Memory Management Test Program *
                   ; ************************************
                   
                   ; Interactive test:
                   ; D <addr> <size>;      - dump memory
                   ; A <size>;             - allocate memory
                   ; R <addr> <size>;      - release memory
                   
                   
                   ; **********************
                   ; * Header Definitions *
                   ; **********************
                   
                   ; *** global/variables.equ ***
                   
                   ; variables in internal ram
                   
0000:              .equ    in,     0x30    ; pointer to input code
0000:              .equ    out,    0x32    ; pointer to ouput code
                   
0000:              .equ    stream_in,      0x34    ; input stream position
0000:              .equ    stream_out,     0x36    ; output stream position
                   
0000:              .equ    memory_list,    0x38    ; pointer to heap list head
0000:              .equ    memory_start,   0x40    ; first allocatable address
0000:              .equ    memory_end,     0x42    ; last allocatable address
                   
0000:              .equ    block_read,     0x44    ; pointers to block device d
0000:              .equ    block_write,    0x46    ; code (read and write funct
                   
0000:              .equ    stack,  0x50    ; beginning of stack
                   
                   ; *** global/sfr.equ ***
                   
                   ; global SFRs
                   
0000:              .equ    auxr,   0x8e    ; auxiliary register 0
0000:              .equ    auxr1,  0xa2    ; auxiliary register 1
                   
                   ; *** serial/sfr.equ ***
                   
                   ; Special function registers for serial interface.
                   ; See chapter 14 of AT89C51ED2 datasheet, page 48ff.
                   
                   ; Internal Baud Rate Generator (BRG), see datasheet page 52.
0000:                      .equ    BRL,    0x9A    ; baud rate reload value
0000:                      .equ    BDRCON, 0x9B    ; BRG control register
                   
                   
                   ; *************
                   ; * Main Code *
                   ; *************
                   
0000:              .org 0
                   
                   ; *** global/init.inc ***
                   
                   ; Initialize stack pointer and global variables.
                   ; This must be included early in the main program.
                   
0000: 75 81 50             mov     SP,     #STACK
                   
                   ; *** test/memory.asm ***
                   
0003: 11 95                acall   serial_init
                   
                           ; use xram
0005: 53 8E E1             anl     auxr,#0xe1      ; clear extram, xrs0-2
0008: 43 8E 10             orl     auxr,#0x10      ; set xrs2 (size 1792 bytes)
                   
                           ; initialize memory list
000B: 90 00 00             mov     dptr,#0000
000E: 85 82 38             mov     memory_list,dpl
0011: 85 83 39             mov     memory_list+1,dph
                           ; list head: pointer to first block
0014: 74 04                mov     a,#4
0016: F5 40                mov     memory_start,a
0018: F0                   movx    @dptr,a
0019: A3                   inc     dptr
001A: E4                   clr     a
001B: F5 41                mov     memory_start+1,a
001D: F0                   movx    @dptr,a
001E: A3                   inc     dptr
                           ; max address of allocatable memory: 0x06ff
001F: 75 42 FF             mov     memory_end,#0xff
0022: 85 06 43             mov     memory_end+1,0x06
                           ; amount of free memory: 1792-4 = 1788 = 0x06fc
0025: 74 FC                mov     a,#0xfc
0027: F0                   movx    @dptr,a
0028: A3                   inc     dptr
0029: 74 06                mov     a,#0x06
002B: F0                   movx    @dptr,a
002C: A3                   inc     dptr
                           ; first entry: pointer to next (null initially)
002D: E4                   clr     a
002E: F0                   movx    @dptr,a
002F: A3                   inc     dptr
0030: F0                   movx    @dptr,a
0031: A3                   inc     dptr
                           ; size of block (same as free memory initially)
0032: 74 FC                mov     a,#0xfc
0034: F0                   movx    @dptr,a
0035: A3                   inc     dptr
0036: 74 06                mov     a,#0x06
0038: F0                   movx    @dptr,a
0039: A3                   inc     dptr
                   
                   loop:
003A: 11 C1                acall   read_char
                   
003C: B4 44 26             cjne    a,#'D',__1
003F: 11 C6                acall   read_hex_32
0041: 88 34                mov     stream_in,r0
0043: 89 35                mov     stream_in+1,r1
0045: 11 C6                acall   read_hex_32
0047: E8                   mov     a,r0
0048: A8 34                mov     r0,stream_in
004A: A9 35                mov     r1,stream_in+1
004C: 7A 00                mov     r2,#0
004E: 7B 00                mov     r3,#0
0050: C0 30                push    in
0052: C0 31                push    in+1
0054: 90 02 66             mov     dptr,#stream_xram_read
0057: 85 82 30             mov     in,dpl
005A: 85 83 31             mov     in+1,dph
005D: 31 AA                acall   dump
005F: D0 31                pop     in+1
0061: D0 30                pop     in
0063: 80 D5                sjmp    loop
                   __1:
0065: B4 41 08             cjne    a,#'A',__2
0068: 11 C6                acall   read_hex_32
006A: 51 89                acall   memory_allocate
006C: 31 55                acall   print_hex_16
006E: 80 1B                sjmp    next
                   __2:
0070: B4 52 14             cjne    a,#'R',__3
0073: 11 C6                acall   read_hex_32
0075: E8                   mov     a,r0
0076: FC                   mov     r4,a
0077: E9                   mov     a,r1
0078: FD                   mov     r5,a
0079: 11 C6                acall   read_hex_32
007B: E8                   mov     a,r0
007C: FA                   mov     r2,a
007D: E9                   mov     a,r1
007E: FB                   mov     r3,a
007F: EC                   mov     a,r4
0080: F8                   mov     r0,a
0081: ED                   mov     a,r5
0082: F9                   mov     r1,a
0083: 71 4E                acall   memory_release
0085: 80 04                sjmp    next
                   __3:
0087: 74 3F                mov     a,#'?'
0089: 31 25                acall   print_char
                   next:
008B: 74 0D                mov     a,#13
008D: 31 25                acall   print_char
008F: 74 0A                mov     a,#10
0091: 31 25                acall   print_char
0093: 80 A5                sjmp    loop
                   
                   
                   ; *********************
                   ; * Library Functions *
                   ; *********************
                   
                   ; *** serial/init.inc ***
                   
                   ; >> void serial_init() <<
                   
                   ; Initialize serial interface.
                   ; - assumes 20MHz clock and X2 mode
                   ; - uses internal baud rate generator
                   ; - speed: 9600 bits per second
                   ; Formula: BRL = 256 - (F_clk / (32 * Baud_Rate))
                   ; ---
                   ; See datasheet page 52 for details,
                   ; also note oscillator diagram on page 16!
                   
                   serial_init:
0095: 75 98 52             mov     SCON,   #0x52   ; SM1, REN, TI
0098: 75 9A BF             mov     BRL,    #191    ; 9600 @20MHz CLK
009B: 75 9B 1E             mov     BDRCON, #0x1e   ; BRR, RBCK, TBCK, SPD
                   
009E: 90 00 B9             mov     dptr,   #serial_rx
00A1: 85 82 30             mov     IN,     DPL
00A4: 85 83 31             mov     IN+1,   DPH
                   
00A7: 90 00 B1             mov     dptr,   #serial_tx
00AA: 85 82 32             mov     OUT,    DPL
00AD: 85 83 33             mov     OUT+1,  DPH
                   
00B0: 22                   ret
                   
                   ; *** serial/tx.inc ***
                   
                   ; >> void serial_tx(char a) <<
                   
                   ; Transmit byte from accumulator.
                   
                   serial_tx:
00B1: 30 99 FD             jnb     TI,     serial_tx
00B4: C2 99                clr     TI
00B6: F5 99                mov     SBUF,   a
00B8: 22                   ret
                   
                   ; *** serial/rx.inc ***
                   
                   ; >> char serial_rx <<
                   
                   ; Receive byte into accumulator.
                   
                   serial_rx:
00B9: 30 98 FD             jnb     RI,     serial_rx
00BC: C2 98                clr     RI
00BE: E5 99                mov     a,      SBUF
00C0: 22                   ret
                   
                   ; *** read/char.inc ***
                   
                   ; >> char read_char() <<
                   
                   ; Read char into accumulator.
                   ; Indirect call to function behind IN pointer.
                   
                   read_char:
00C1: C0 30                push    IN
00C3: C0 31                push    IN+1
00C5: 22                   ret
                   
                   ; *** read/char.inc ***
                   
                   ; >> uint32 read_hex_32() <<
                   
                   ; Read 32 bit hex integer from input into r0-r3.
                   ; Stops at the first non-hex character or integer overflow.
                   
                   read_hex_32:
00C6: C0 E0                push    acc
00C8: EC                   mov     a,      r4
00C9: C0 E0                push    acc
00CB: ED                   mov     a,      r5
00CC: C0 E0                push    acc
                   
00CE: E4                   clr     a
00CF: F8                   mov     r0,     a
00D0: F9                   mov     r1,     a
00D1: FA                   mov     r2,     a
00D2: FB                   mov     r3,     a
                   
                   read_hex_32__loop:
00D3: 11 C1                acall   read_char
                   
00D5: C3                   clr     c
00D6: 94 30                subb    a,      #0x30   ; ascii '0'
00D8: 40 42                jc      read_hex_32__end
00DA: B4 0A 00             cjne    a,      #10,    read_hex_32__1
                   read_hex_32__1:
00DD: 40 0D                jc      read_hex_32__3
00DF: 94 11                subb    a,      #17     ; chars between '0' and 'A'
00E1: 40 39                jc      read_hex_32__end
00E3: 24 0A                add     a,      #10
00E5: 54 DF                anl     a,      #0xdf   ; allow lowercase
00E7: B4 10 00             cjne    a,      #0x10,  read_hex_32__2
                   read_hex_32__2:
00EA: 50 30                jnc     read_hex_32__end
                   
                   read_hex_32__3:
00EC: FC                   mov     r4,     a
00ED: E8                   mov     a,      r0
00EE: C4                   swap    a
00EF: FD                   mov     r5,     a
00F0: 54 F0                anl     a,      #0xf0
00F2: 4C                   orl     a,      r4
00F3: F8                   mov     r0,     a
00F4: ED                   mov     a,      r5
00F5: 54 0F                anl     a,      #0x0f
                   
00F7: FC                   mov     r4,     a
00F8: E9                   mov     a,      r1
00F9: C4                   swap    a
00FA: FD                   mov     r5,     a
00FB: 54 F0                anl     a,      #0xf0
00FD: 4C                   orl     a,      r4
00FE: F9                   mov     r1,     a
00FF: ED                   mov     a,      r5
0100: 54 0F                anl     a,      #0x0f
                   
0102: FC                   mov     r4,     a
0103: EA                   mov     a,      r2
0104: C4                   swap    a
0105: FD                   mov     r5,     a
0106: 54 F0                anl     a,      #0xf0
0108: 4C                   orl     a,      r4
0109: FA                   mov     r2,     a
010A: ED                   mov     a,      r5
010B: 54 0F                anl     a,      #0x0f
                   
010D: FC                   mov     r4,     a
010E: EB                   mov     a,      r3
010F: C4                   swap    a
0110: FD                   mov     r5,     a
0111: 54 F0                anl     a,      #0xf0
0113: 4C                   orl     a,      r4
0114: FB                   mov     r3,     a
0115: ED                   mov     a,      r5
0116: 54 0F                anl     a,      #0x0f
                   
0118: 70 02                jnz     read_hex_32__end        ; overflow
011A: 80 B7                sjmp    read_hex_32__loop
                   
                   
                   read_hex_32__end:
011C: D0 E0                pop     acc
011E: FD                   mov     r5,     a
011F: D0 E0                pop     acc
0121: FC                   mov     r4,     a
0122: D0 E0                pop     acc
0124: 22                   ret
                   
                   ; *** print/char.inc ***
                   
                   ; >> void print_char(char a) <<
                   
                   ; Print char from accumulator.
                   ; Indirect call to function behind OUT pointer.
                   
                   print_char:
0125: C0 32                push    OUT
0127: C0 33                push    OUT+1
0129: 22                   ret
                   
                   ; *** print/text.inc ***
                   
                   ; >> void print_text(char* dptr) <<
                   
                   ; Print null-terminated string from program code.
                   ; Aborts if no null terminator is found after 256 bytes.
                   
                   print_text:
012A: C0 E0                push    ACC
012C: E8                   mov     a,      r0
012D: C0 E0                push    ACC
                   
012F: E4                   clr     a
0130: F8                   mov     r0,     a
                   print_text__loop:
0131: 93                   movc    a,      @dptr+a
0132: 60 06                jz      print_text__end
0134: 31 25                acall   print_char
0136: 08                   inc     r0
0137: E8                   mov     a,      r0
0138: 70 F7                jnz     print_text__loop
                   
                   print_text__end:
013A: D0 E0                pop     ACC
013C: F8                   mov     r0,     a
013D: D0 E0                pop     ACC
013F: 22                   ret
                   
                   ; *** print/hex.inc ***
                   
                   ; >> void print_hex_8(char a) <<
                   
                   ; Print hexadecimal number from accumulator.
                   
                   print_hex_8:
0140: C4                   swap    a       ; high nibble first
0141: 31 44                acall   print_hex_8__nibble
0143: C4                   swap    a
                   print_hex_8__nibble:
0144: C0 E0                push    ACC
0146: 54 0F                anl     a,      #0x0f
0148: 24 90                add     a,      #0x90
014A: D4                   da      a
014B: 34 40                addc    a,      #0x40
014D: D4                   da      a
014E: 44 20                orl     a,      #0x20   ; lower case
0150: 31 25                acall   print_char
0152: D0 E0                pop     ACC
0154: 22                   ret
                   
                   ; >> void print_hex_16(int r0r1) <<
                   
                   ; Print hexadecimal number from r0-r1.
                   
                   print_hex_16:
0155: C0 E0                push    ACC
0157: E9                   mov     a,      r1      ; MSB first
0158: 31 40                acall   print_hex_8
015A: E8                   mov     a,      r0      ; LSB second
015B: 31 40                acall   print_hex_8
015D: D0 E0                pop     ACC
015F: 22                   ret
                   
                   ; >> void print_hex_32(long r0r1r2r3) <<
                   
                   ; Print hexadecimal number from r0-r3.
                   
                   print_hex_32:
0160: C0 E0                push    ACC
0162: EB                   mov     a,      r3      ; MSB first
0163: 31 40                acall   print_hex_8
0165: EA                   mov     a,      r2
0166: 31 40                acall   print_hex_8
0168: E9                   mov     a,      r1
0169: 31 40                acall   print_hex_8
016B: E8                   mov     a,      r0      ; LSB last
016C: 31 40                acall   print_hex_8
016E: D0 E0                pop     ACC
0170: 22                   ret
                   
                   ; *** util/xch.inc ***
                   
                   ; >> void xch_r0123_r4567(uint32 &r0r1r2r3, uint32 &r4r5r6r7
                   
                   ; Exchange registers r0-r3 with r4-r7.
                   
                   xch_r0123_r4567:
                           ; r0 <-> r4
0171: C8                   xch     a,      r0
0172: CC                   xch     a,      r4
0173: C8                   xch     a,      r0
                           ; r1 <-> r5
0174: C9                   xch     a,      r1
0175: CD                   xch     a,      r5
0176: C9                   xch     a,      r1
                           ; r2 <-> r6
0177: CA                   xch     a,      r2
0178: CE                   xch     a,      r6
0179: CA                   xch     a,      r2
                           ; r3 <-> r7
017A: CB                   xch     a,      r3
017B: CF                   xch     a,      r7
017C: CB                   xch     a,      r3
                           ; a remains unchanged
017D: 22                   ret
                   
                   ; *** util/regbank.inc ***
                   
                   ; >> void* regbank_next() <<
                   
                   ; Switch to next register bank.
                   ; Return pointer to r0 of old bank in new r0.
                   
                   regbank_next:
017E: C0 E0                push    acc
                           ; check if already at highest bank
0180: E5 D0                mov     a,      psw
0182: 54 18                anl     a,      #0x18
0184: B4 18 02             cjne    a,      #0x18,  regbank_next__continue
0187: 91 74                acall   panic   ; overflow
                   regbank_next__continue:
                           ; switch to next bank
0189: E5 D0                mov     a,      psw
018B: 24 08                add     a,      #0x08
018D: F5 D0                mov     psw,    a
                           ; calculate pointer to old bank
018F: 54 18                anl     a,      #0x18
0191: 24 F8                add     a,      #0xf8
0193: F8                   mov     r0,     a
                           ; done
0194: D0 E0                pop     acc
0196: 22                   ret
                   
                   ; >> void regbank_prev() <<
                   
                   ; Switch to previous register bank.
                   
                   regbank_prev:
0197: C0 E0                push    acc
                           ; check if already at lowest bank
0199: E5 D0                mov     a,      psw
019B: 54 18                anl     a,      #0x18
019D: 70 02                jnz     regbank_prev__continue
019F: 91 74                acall   panic   ; underflow
                   regbank_prev__continue:
                           ; switch to previous bank
01A1: E5 D0                mov     a,      psw
01A3: 24 F8                add     a,      #0xf8
01A5: F5 D0                mov     psw,    a
                           ; done
01A7: D0 E0                pop     acc
01A9: 22                   ret
                   
                   ; *** util/dump.inc ***
                   
                   ; >> uint32{r0-r3} dump(uint32{r0-r3} addr, uint8{a} count) 
                   
                   ; Print hexdump from standard input to standard output.
                   ; Starting value for address column in r0-r3.
                   ; Number of bytes to print in a (0 means 256).
                   ; r0-r3 contains next address upon exit.
                   
                   dump:
01AA: C0 F0                push    b
01AC: C0 E0                push    acc
01AE: F5 F0                mov     b,      a
01B0: EC                   mov     a,      r4
01B1: C0 E0                push    acc
01B3: ED                   mov     a,      r5
01B4: C0 E0                push    acc
01B6: EE                   mov     a,      r6
01B7: C0 E0                push    acc
01B9: EF                   mov     a,      r7
01BA: C0 E0                push    acc
                   
                           ; b: total bytes remaining
                           ; r0: buffer pointer
                           ; r1: read loop counter / padding size
                           ; r2: print loop counter
                   
                           ; r4-7: address label
01BC: 31 71                acall   xch_r0123_r4567
                   
                           ; allocate 16 byte array on stack
01BE: E5 81                mov     a,      sp
01C0: F8                   mov     r0,     a
01C1: 24 10                add     a,      #16
01C3: F5 81                mov     sp,     a
                   
                   dump__line_loop:
                           ; read into buffer
01C5: 79 10                mov     r1,     #16
                   dump__read_loop:
01C7: 11 C1                acall   read_char
01C9: 08                   inc     r0
01CA: F6                   mov     @r0,    a
01CB: D5 F0 03             djnz    b,      dump__read_continue
01CE: 19                   dec     r1
01CF: 80 02                sjmp    dump__read_end
                   dump__read_continue:
01D1: D9 F4                djnz    r1,     dump__read_loop
                   dump__read_end:
                   
                           ; print address column
01D3: 31 71                acall   xch_r0123_r4567
01D5: 31 60                acall   print_hex_32
01D7: 31 71                acall   xch_r0123_r4567
01D9: 74 3A                mov     a,      #':'
01DB: 31 25                acall   print_char
                   
                           ; if r1 is nonzero here, we have a shorter line
                           ; the value in r1 is the number of padding bytes
                   
                           ; wind back pointer
01DD: E8                   mov     a,      r0
01DE: 24 F0                add     a,      #-16
01E0: 29                   add     a,      r1
01E1: F8                   mov     r0,     a
                   
                           ; print hex
01E2: 7A 10                mov     r2,     #16
                   dump__print_hex_loop:
01E4: 08                   inc     r0
01E5: EA                   mov     a,      r2
01E6: 54 03                anl     a,      #3      ; mod 4
01E8: 70 04                jnz     dump__print_hex_no_gap
01EA: 74 20                mov     a,      #' ' ; gap after every 4 bytes
01EC: 31 25                acall   print_char
                   dump__print_hex_no_gap:
01EE: EA                   mov     a,      r2
01EF: D3                   setb    c
01F0: 99                   subb    a,      r1
01F1: 50 08                jnc     dump__print_hex_no_padding
01F3: 74 20                mov     a,      #' ' ; padding for shorter line
01F5: 31 25                acall   print_char
01F7: 31 25                acall   print_char
01F9: 80 03                sjmp    dump__print_hex_next
                   dump__print_hex_no_padding:
01FB: E6                   mov     a,      @r0
01FC: 31 40                acall   print_hex_8
                   dump__print_hex_next:
01FE: 74 20                mov     a,      #' ' ; space between bytes
0200: 31 25                acall   print_char
0202: DA E0                djnz    r2,     dump__print_hex_loop
                   
                           ; wind back again
0204: E8                   mov     a,      r0
0205: 24 F0                add     a,      #-16
0207: F8                   mov     r0,     a
                   
                           ; print ascii
0208: 74 20                mov     a,      #' '
020A: 31 25                acall   print_char
020C: 74 7C                mov     a,      #'|'
020E: 31 25                acall   print_char
0210: 74 10                mov     a,      #16
0212: C3                   clr     c
0213: 99                   subb    a,      r1
0214: F9                   mov     r1,     a ; number of bytes to print
0215: FA                   mov     r2,     a
                   dump__print_ascii_loop:
0216: 08                   inc     r0
0217: E6                   mov     a,      @r0
0218: B4 20 00             cjne    a,      #0x20,  dump__print_ascii_check1
                   dump__print_ascii_check1:
021B: 40 05                jc      dump__print_ascii_replace
021D: B4 7F 00             cjne    a,      #0x7f,  dump__print_ascii_check2
                   dump__print_ascii_check2:
0220: 40 02                jc      dump__print_ascii_continue
                   dump__print_ascii_replace:
0222: 74 2E                mov     a,      #'.'
                   dump__print_ascii_continue:
0224: 31 25                acall   print_char
0226: DA EE                djnz    r2,     dump__print_ascii_loop
0228: 74 7C                mov     a,      #'|'
022A: 31 25                acall   print_char
022C: 74 0D                mov     a,      #13
022E: 31 25                acall   print_char
0230: 74 0A                mov     a,      #10
0232: 31 25                acall   print_char
                   
                           ; wind back again
0234: E8                   mov     a,      r0
0235: 24 F0                add     a,      #-16
0237: F8                   mov     r0,     a
                   
                           ; next address
0238: EC                   mov     a,      r4
0239: 29                   add     a,      r1
023A: FC                   mov     r4,     a
023B: ED                   mov     a,      r5
023C: 34 00                addc    a,      #0
023E: FD                   mov     r5,     a
023F: EE                   mov     a,      r6
0240: 34 00                addc    a,      #0
0242: FE                   mov     r6,     a
0243: EF                   mov     a,      r7
0244: 34 00                addc    a,      #0
0246: FF                   mov     r7,     a
                   
0247: E5 F0                mov     a,      b
0249: 60 02                jz      dump__end
024B: 21 C5                ajmp    dump__line_loop
                   
                   dump__end:
                           ; deallocate array from stack
024D: E5 81                mov     a,      sp
024F: 24 F0                add     a,      #-16
0251: F5 81                mov     sp,     a
                   
0253: 31 71                acall   xch_r0123_r4567
                   
0255: D0 E0                pop     acc
0257: FF                   mov     r7,     a
0258: D0 E0                pop     acc
025A: FE                   mov     r6,     a
025B: D0 E0                pop     acc
025D: FD                   mov     r5,     a
025E: D0 E0                pop     acc
0260: FC                   mov     r4,     a
0261: D0 E0                pop     acc
0263: D0 F0                pop     b
0265: 22                   ret
                   
                   ; *** stream/xram_read.inc ***
                   
                   ; >> char stream_xram_read() <<
                   
                   ; Read byte from on-chip expanded RAM at stream input pointe
                   ; 16 bit value of the stream pointer is used and incremented
                   
                   stream_xram_read:
0266: C0 8E                push    auxr
0268: C0 82                push    dpl
026A: C0 83                push    dph
                   
026C: E5 8E                mov     a,      auxr
026E: 55 E1                anl     a,      0xe1    ; clear extram, xrs0-2
0270: 45 10                orl     a,      0x10    ; set xrs2 (size 1792 bytes)
0272: F5 8E                mov     auxr,   a
                   
0274: 85 34 82             mov     dpl,    stream_in
0277: 85 35 83             mov     dph,    stream_in+1
                   
027A: E0                   movx    a,      @dptr
027B: A3                   inc     dptr
027C: 85 82 34             mov     stream_in,      dpl
027F: 85 83 35             mov     stream_in+1,    dph
                   
0282: D0 83                pop     dph
0284: D0 82                pop     dpl
0286: D0 8E                pop     auxr
0288: 22                   ret
                   
                   ; *** memory/allocate.inc ***
                   
                   ; >> r0r1 *memory_allocate(r0r1 size) <<
                   
                   ; Allocate memory, return lowest address
                   
                   memory_allocate:
0289: C0 A8                push    ie
028B: C2 AF                clr     ea
                   
028D: C0 E0                push    acc
028F: C0 82                push    dpl
0291: C0 83                push    dph
                   
0293: 31 7E                acall   regbank_next
0295: E6                   mov     a,@r0
0296: FE                   mov     r6,a
0297: 08                   inc     r0
0298: E6                   mov     a,@r0
0299: FF                   mov     r7,a ; size param now in r6r7
                   
029A: EE                   mov     a,r6
029B: 4F                   orl     a,r7
029C: 70 02                jnz     memory_allocate__0
029E: 91 74                acall   panic   ; invalid size (0)
                   
                   memory_allocate__0:
                           ; rounding to next multiple of 4
02A0: EE                   mov     a,r6
02A1: 24 03                add     a,#3
02A3: 54 FC                anl     a,#0xfc
02A5: FE                   mov     r6,a
02A6: EF                   mov     a,r7
02A7: 34 00                addc    a,#0
02A9: FF                   mov     r7,a
                   
                           ; set prev (r2,r3) and curr (r4r5) pointers
02AA: AA 38                mov     r2,memory_list
02AC: AB 39                mov     r3,memory_list+1
02AE: 8A 82                mov     dpl,r2
02B0: 8B 83                mov     dph,r3
02B2: E0                   movx    a,@dptr
02B3: FC                   mov     r4,a
02B4: A3                   inc     dptr
02B5: E0                   movx    a,@dptr
02B6: FD                   mov     r5,a
                   
                   memory_allocate__loop:
02B7: EC                   mov     a,r4
02B8: 4D                   orl     a,r5
02B9: 70 02                jnz     memory_allocate__0a
02BB: 91 74                acall   panic   ; no large enough free block found
                   memory_allocate__0a:
                           ; compare curr->size with required size
02BD: 8C 82                mov     dpl,r4
02BF: 8D 83                mov     dph,r5
02C1: A3                   inc     dptr
02C2: A3                   inc     dptr    ; dptr is now &(curr->size)
02C3: E0                   movx    a,@dptr
02C4: F9                   mov     r1,a    ; store low byte for later (cannot e
02C5: A3                   inc     dptr    ; compare high byte first
02C6: C3                   clr     c
02C7: E0                   movx    a,@dptr
02C8: 9F                   subb    a,r7
02C9: 70 1C                jnz     memory_allocate__1
02CB: E9                   mov     a,r1
02CC: 9E                   subb    a,r6
02CD: 70 18                jnz     memory_allocate__1
                   
                           ; block size is exact match
02CF: 8A 82                mov     dpl,r2  ; prev
02D1: 8B 83                mov     dph,r3
02D3: 05 A2                inc     auxr1   ;*switch data pointers
02D5: 8C 82                mov     dpl,r4  ; curr
02D7: 8D 83                mov     dph,r5
                           ; prev->next = curr->next
02D9: E0                   movx    a,@dptr
02DA: A3                   inc     dptr
02DB: 05 A2                inc     auxr1   ;*
02DD: F0                   movx    @dptr,a
02DE: A3                   inc     dptr
02DF: 05 A2                inc     auxr1   ;*
02E1: E0                   movx    a,@dptr
02E2: 05 A2                inc     auxr1   ;*
02E4: F0                   movx    @dptr,a
02E5: 80 47                sjmp    memory_allocate__success
                   
                   memory_allocate__1:
02E7: 50 0F                jnc     memory_allocate__2 ; jump if curr is larger 
                           ; too small, move on to next entry in list
02E9: EC                   mov     a,r4    ; -.
02EA: FA                   mov     r2,a    ;  |- prev = curr
02EB: ED                   mov     a,r5    ;  |
02EC: FB                   mov     r3,a    ; -'
02ED: 8C 82                mov     dpl,r4  ; -.
02EF: 8D 82                mov     dpl,r5  ;  |
02F1: E0                   movx    a,@dptr ;  |
02F2: FC                   mov     r4,a    ;  |- curr = curr->next
02F3: A3                   inc     dptr    ;  |
02F4: E0                   movx    a,@dptr ;  |
02F5: FD                   mov     r5,a    ; -'
02F6: 80 BF                sjmp    memory_allocate__loop
                   
                   memory_allocate__2:
                           ; split big block
02F8: 8A 82                mov     dpl,r2  ; prev
02FA: 8B 83                mov     dph,r3  ;
02FC: EC                   mov     a,r4    ; -.
02FD: 2E                   add     a,r6    ;  |
02FE: FA                   mov     r2,a    ;  |
02FF: F0                   movx    @dptr,a ;  |
0300: A3                   inc     dptr    ;  |- prev->next = curr+size
0301: ED                   mov     a,r5    ;  |               '---.---'
0302: 3F                   addc    a,r7    ;  |  pointer to leftover block
0303: FB                   mov     r3,a    ;  |  also gets stored in r2r3
0304: F0                   movx    @dptr,a ; -' (prev is not needed anymore)
                   
0305: 8A 82                mov     dpl,r2  ; leftover
0307: 8B 83                mov     dph,r3
0309: 05 A2                inc     auxr1   ;*switch data pointers
030B: 8C 82                mov     dpl,r4  ; curr
030D: 8D 83                mov     dph,r5
030F: E0                   movx    a,@dptr ; -.
0310: A3                   inc     dptr    ;  |
0311: 05 A2                inc     auxr1   ;* |
0313: F0                   movx    @dptr,a ;  |
0314: A3                   inc     dptr    ;  |
0315: 05 A2                inc     auxr1   ;* |- leftover->next = curr->next
0317: E0                   movx    a,@dptr ;  |
0318: A3                   inc     dptr    ;  |
0319: 05 A2                inc     auxr1   ;* |
031B: F0                   movx    @dptr,a ;  |
031C: A3                   inc     dptr    ; -'
                           ; data pointers are now &(leftover->size) and &(curr
031D: 05 A2                inc     auxr1   ;*-.
031F: E0                   movx    a,@dptr ;  |
0320: A3                   inc     dptr    ;  |
0321: C3                   clr     c       ;  |
0322: 9E                   subb    a,r6    ;  |
0323: 05 A2                inc     auxr1   ;* |
0325: F0                   movx    @dptr,a ;  |- leftover->size = curr->size - 
0326: A3                   inc     dptr    ;  |
0327: 05 A2                inc     auxr1   ;* |
0329: E0                   movx    a,@dptr ;  |
032A: 9F                   subb    a,r7    ;  |
032B: 05 A2                inc     auxr1   ;* |
032D: F0                   movx    @dptr,a ; -'
                   
                   memory_allocate__success:
032E: 85 38 82             mov     dpl,memory_list
0331: 85 39 83             mov     dph,memory_list+1
0334: A3                   inc     dptr    ; -.
0335: A3                   inc     dptr    ;  |
0336: E0                   movx    a,@dptr ;  |
0337: C3                   clr     c       ;  |
0338: 9E                   subb    a,r6    ;  |- memory_list->free -= size
0339: F0                   movx    @dptr,a ;  |
033A: A3                   inc     dptr    ;  |
033B: E0                   movx    a,@dptr ;  |
033C: 9F                   subb    a,r7    ;  |
033D: F0                   movx    @dptr,a ; -'
                   
033E: ED                   mov     a,r5    ; -.
033F: F6                   mov     @r0,a   ;  |
0340: 18                   dec     r0      ;  |- return curr
0341: EC                   mov     a,r4    ;  |
0342: F6                   mov     @r0,a   ; -'
                   
0343: 31 97                acall   regbank_prev
0345: D0 83                pop     dph
0347: D0 82                pop     dpl
0349: D0 E0                pop     acc
                   
034B: D0 A8                pop     ie
034D: 22                   ret
                   
                   ; *** memory/release.inc ***
                   
                   ; >> void release(r0r1 *addr, r2r3 size) <<
                   
                   ; Allocate memory, return lowest address
                   
                   memory_release:
034E: C0 A8                push    ie
0350: C2 AF                clr     ea
                           
0352: C0 E0                push    acc
0354: C0 82                push    dpl
0356: C0 83                push    dph
                   
0358: 31 7E                acall   regbank_next
                   
035A: E8                   mov     a,r0
035B: 24 03                add     a,#3
035D: F8                   mov     r0,a
                           ; r6r7 <- size
035E: E6                   mov     a,@r0
035F: FF                   mov     r7,a
0360: 18                   dec     r0
0361: E6                   mov     a,@r0
0362: FE                   mov     r6,a
0363: 18                   dec     r0
                           ; r0r1 <- pointer to block
0364: E6                   mov     a,@r0
0365: F9                   mov     r1,a
0366: 18                   dec     r0
0367: E6                   mov     a,@r0
0368: F8                   mov     r0,a
                   
                           ; input parameter check
0369: EE                   mov     a,r6
036A: 4F                   orl     a,r7
036B: 70 02                jnz     memory_release__1
036D: 91 74                acall   panic   ; invalid size (0)
                   memory_release__1:
036F: E9                   mov     a,r1
0370: B5 41 04             cjne    a,memory_start+1,memory_release__2
0373: E8                   mov     a,r0
0374: B5 40 00             cjne    a,memory_start,memory_release__2
                   memory_release__2:
0377: 50 02                jnc     memory_release__3
0379: 91 74                acall   panic   ; invalid address (< memory_start)
                   memory_release__3:
037B: E9                   mov     a,r1
037C: B5 43 04             cjne    a,memory_end+1,memory_release__4
037F: E8                   mov     a,r0
0380: B5 42 00             cjne    a,memory_end,memory_release__4
                   memory_release__4:
0383: 40 02                jc      memory_release__5
0385: 91 74                acall   panic   ; invalid address (>= memory_end)
                   memory_release__5:
                   
                           ; rounding
0387: EE                   mov     a,r6
0388: 24 03                add     a,#3
038A: 54 FC                anl     a,#0xfc
038C: FE                   mov     r6,a
038D: EF                   mov     a,r7
038E: 34 00                addc    a,#0
0390: FF                   mov     r7,a
                   
                           ; find position in list
                           ; r2r3: prev pointer
                           ; r4r5: next pointer
0391: AA 38                mov     r2,memory_list
0393: AB 39                mov     r3,memory_list+1
0395: 8A 82                mov     dpl,r2
0397: 8B 83                mov     dph,r3
0399: E0                   movx    a,@dptr
039A: FC                   mov     r4,a
039B: A3                   inc     dptr
039C: E0                   movx    a,@dptr
039D: FD                   mov     r5,a
                   memory_release__loop:
039E: EC                   mov     a,r4
039F: 4D                   orl     a,r5
03A0: 60 1C                jz      memory_release__7       ; next == null
03A2: C3                   clr     c
03A3: ED                   mov     a,r5
03A4: 99                   subb    a,r1
03A5: 70 06                jnz     memory_release__6
03A7: EC                   mov     a,r4
03A8: 98                   subb    a,r0
03A9: 70 02                jnz     memory_release__6
03AB: 91 74                acall   panic   ; double free   (next == block)
                   memory_release__6:
03AD: 50 0F                jnc     memory_release__7       ; next > block
03AF: EC                   mov     a,r4    ; -.
03B0: FA                   mov     r2,a    ;  |- prev = next
03B1: ED                   mov     a,r5    ;  |
03B2: FB                   mov     r3,a    ; -'
03B3: 8C 82                mov     dpl,r4  ; -.
03B5: 8D 83                mov     dph,r5  ;  |
03B7: E0                   movx    a,@dptr ;  |
03B8: FC                   mov     r4,a    ;  |- next = next->next
03B9: A3                   inc     dptr    ;  |
03BA: E0                   movx    a,@dptr ;  |
03BB: FD                   mov     r5,a    ; -'
                   
03BC: 80 E0                sjmp    memory_release__loop
                   
                   memory_release__7:
                           ; if (prev == memory_list) ...
03BE: EB                   mov     a,r3
03BF: B5 39 06             cjne    a,memory_list+1,memory_release__8
03C2: EA                   mov     a,r2
03C3: B5 38 02             cjne    a,memory_list,memory_release__8
03C6: 80 30                sjmp    memory_release__link_new ; ... link as new f
                           ; ... else:
                   memory_release__8:
                           ; compute top of previous block
03C8: 8A 82                mov     dpl,r2
03CA: 8B 83                mov     dph,r3
03CC: A3                   inc     dptr
03CD: A3                   inc     dptr    ; prev->size
                           ; top = prev + prev->size
03CE: E0                   movx    a,@dptr
03CF: 2A                   add     a,r2
03D0: C0 E0                push    acc     ;-.
03D2: A3                   inc     dptr    ; |
03D3: E0                   movx    a,@dptr ; |
03D4: 3B                   addc    a,r3    ; |
03D5: F5 83                mov     dph,a   ; |
03D7: D0 82                pop     dpl     ;<' dptr = top
                   
                           ; if (block == top) ...
03D9: E9                   mov     a,r1
03DA: B5 83 17             cjne    a,dph,memory_release__9
03DD: E8                   mov     a,r0
03DE: B5 82 13             cjne    a,dpl,memory_release__9
                           ; ... coalsece with previous block ...
03E1: 8A 82                mov     dpl,r2
03E3: 8B 83                mov     dph,r3
03E5: A3                   inc     dptr
03E6: A3                   inc     dptr    ; prev->size
03E7: E0                   movx    a,@dptr ; -.
03E8: 2E                   add     a,r6    ;  |- += size
03E9: F0                   movx    @dptr,a ;  |
03EA: A3                   inc     dptr    ;  |
03EB: E0                   movx    a,@dptr ;  |
03EC: 3F                   addc    a,r7    ;  |
03ED: F0                   movx    @dptr,a ; -'
03EE: EA                   mov     a,r2    ; -.
03EF: F8                   mov     r0,a    ;  |- block = prev
03F0: EB                   mov     a,r3    ;  |
03F1: F9                   mov     r1,a    ; -'
03F2: 80 1C                sjmp    memory_release__10
                           ; ... else:
                   memory_release__9:
03F4: 50 02                jnc     memory_release__link_new ; ... link as new b
03F6: 91 74                acall   panic   ; error: block < top (overlap)
                   
                   memory_release__link_new:
                           ; link into list as new node
03F8: 88 82                mov     dpl,r0  ; -.
03FA: 89 83                mov     dph,r1  ;  |
03FC: EC                   mov     a,r4    ;  |
03FD: F0                   movx    @dptr,a ;  |- block->next = next
03FE: A3                   inc     dptr    ;  |
03FF: ED                   mov     a,r5    ;  |
0400: F0                   movx    @dptr,a ; -'
0401: A3                   inc     dptr    ; -.
0402: EE                   mov     a,r6    ;  |
0403: F0                   movx    @dptr,a ;  |- block->size = size
0404: A3                   inc     dptr    ;  |
0405: EF                   mov     a,r7    ;  |
0406: F0                   movx    @dptr,a ; -'
0407: 8A 82                mov     dpl,r2  ; -.
0409: 8B 83                mov     dph,r3  ;  |
040B: E8                   mov     a,r0    ;  |
040C: F0                   movx    @dptr,a ;  |- prev->next = block
040D: A3                   inc     dptr    ;  |
040E: E9                   mov     a,r1    ;  |
040F: F0                   movx    @dptr,a ; -'
                           ; last use of prev in r2r3
                   
                   memory_release__10:
                           ; check if block is touching next block
0410: 88 82                mov     dpl,r0
0412: 89 83                mov     dph,r1
0414: A3                   inc     dptr
0415: A3                   inc     dptr    ; block->size
0416: E0                   movx    a,@dptr
0417: 28                   add     a,r0
0418: FA                   mov     r2,a    ; r2 used as temp storage here
0419: A3                   inc     dptr
041A: E0                   movx    a,@dptr
041B: 39                   addc    a,r1
041C: F5 83                mov     dph,a
041E: 8A 82                mov     dpl,r2 ; dptr: block + block->size
                   
0420: ED                   mov     a,r5
0421: B5 83 32             cjne    a,dph,memory_release__11
0424: EC                   mov     a,r4
0425: B5 82 2E             cjne    a,dpl,memory_release__11
                   
                           ; coalesce with next block
0428: 88 82                mov     dpl,r0  ; -.
042A: 89 83                mov     dph,r1  ;  |
042C: 05 A2                inc     auxr1   ; *|
042E: 8C 82                mov     dpl,r4  ;  |
0430: 8D 83                mov     dph,r5  ;  |
0432: E0                   movx    a,@dptr ;  |
0433: A3                   inc     dptr    ;  |
0434: 05 A2                inc     auxr1   ;* |- block->next = next->next
0436: F0                   movx    @dptr,a ;  |
0437: A3                   inc     dptr    ;  |
0438: 05 A2                inc     auxr1   ; *|
043A: E0                   movx    a,@dptr ;  |
043B: A3                   inc     dptr    ;  |
043C: 05 A2                inc     auxr1   ;* |
043E: F0                   movx    @dptr,a ; -'
043F: A3                   inc     dptr    ; -.
0440: 05 A2                inc     auxr1   ; *|
0442: E0                   movx    a,@dptr ;  |
0443: A3                   inc     dptr    ;  |
0444: FA                   mov     r2,a    ;  |
0445: 05 A2                inc     auxr1   ;* |
0447: E0                   movx    a,@dptr ;  |
0448: 2A                   add     a,r2    ;  |
0449: F0                   movx    @dptr,a ;  |- block->size += next->size
044A: A3                   inc     dptr    ;  |
044B: 05 A2                inc     auxr1   ; *|
044D: E0                   movx    a,@dptr ;  |
044E: FB                   mov     r3,a    ;  |
044F: 05 A2                inc     auxr1   ;* |
0451: E0                   movx    a,@dptr ;  |
0452: 3B                   addc    a,r3    ;  |
0453: F0                   movx    @dptr,a ; -'
0454: 80 04                sjmp    memory_release__end
                   
                   memory_release__11:
0456: 50 02                jnc     memory_release__end
0458: 91 74                acall   panic   ; error: next < block+block->size
                   
                   memory_release__end:
045A: 85 38 82             mov     dpl,memory_list
045D: 85 39 83             mov     dph,memory_list+1
0460: A3                   inc     dptr
0461: A3                   inc     dptr
0462: E0                   movx    a,@dptr
0463: 2E                   add     a,r6
0464: F0                   movx    @dptr,a
0465: A3                   inc     dptr
0466: E0                   movx    a,@dptr
0467: 3F                   addc    a,r7
0468: F0                   movx    @dptr,a
                   
0469: 31 97                acall   regbank_prev
046B: D0 83                pop     dph
046D: D0 82                pop     dpl
046F: D0 E0                pop     acc
0471: D0 A8                pop     ie
0473: 22                   ret
                   
0474:              .equ panic_out, serial_tx
                   
                   ; *** panic/panic.inc ***
                   
                   ; >> void panic() <<
                   
                   ; Unrecoverable error handler.
                   ; Print caller address and halt.
                   
                   panic:
0474: C2 AF                clr     ea      ; disable interrupts
0476: 90 00 B1             mov     dptr,   #panic_out
0479: 85 82 32             mov     out,    dpl
047C: 85 83 33             mov     out+1,  dph
047F: 90 04 8E             mov     dptr,   #panic_text
0482: 31 2A                acall   print_text
0484: D0 E0                pop     acc
0486: 31 40                acall   print_hex_8
0488: D0 E0                pop     acc
048A: 31 40                acall   print_hex_8
048C: 80 FE                sjmp    *
                   
                   panic_text:
048E: 0D 0A                .db     13, 10
0490: 20 21 21 21 
      20 70 61 6E 
      69 63 20 40 
                           .db     " !!! panic @"
049C: 00                   .db     0
