                   
                   ; ************************************
                   ; * Memory Management Test Program *
                   ; ************************************
                   
                   ; Interactive test:
                   ; D <addr> <size>;       - dump memory
                   ; A <size>;              - allocate memory
                   ; R <addr> <size>;       - release memory
                   
                   
                   ; **********************
                   ; * Header Definitions *
                   ; **********************
                   
                   ; *** global/variables.equ ***
                   
                   ; variables in internal ram
                   
0000:              .equ     in,     0x30    ; pointer to input code
0000:              .equ     out,    0x32    ; pointer to ouput code
                   
0000:              .equ     stream_in,      0x34    ; input stream position
0000:              .equ     stream_out,     0x36    ; output stream position
                   
0000:              .equ     memory_list,    0x38    ; pointer to heap list head
0000:              .equ     memory_start,   0x40    ; first allocatable address
0000:              .equ     memory_end,     0x42    ; last allocatable address
                   
0000:              .equ     stack,  0x50    ; beginning of stack
                   
                   ; *** global/sfr.equ ***
                   
                   ; global SFRs
                   
0000:              .equ     auxr,   0x8e    ; auxiliary register 0
0000:              .equ     auxr1,  0xa2    ; auxiliary register 1
                   
                   ; *** serial/sfr.equ ***
                   
                   ; Special function registers for serial interface.
                   ; See chapter 14 of AT89C51ED2 datasheet, page 48ff.
                   
                   ; Internal Baud Rate Generator (BRG), see datasheet page 52.
0000:                       .equ    BRL,    0x9A    ; baud rate reload value
0000:                       .equ    BDRCON, 0x9B    ; BRG control register
                   
                   
                   ; *************
                   ; * Main Code *
                   ; *************
                   
0000:              .org 0
                   
                   ; *** global/init.inc ***
                   
                   ; Initialize stack pointer and global variables.
                   ; This must be included early in the main program.
                   
0000: 75 81 50              mov     SP,     #STACK
                   
0003: 90 00 BB              mov     dptr,   #serial_rx
0006: 85 82 30              mov     IN,     DPL
0009: 85 83 31              mov     IN+1,   DPH
                   
000C: 90 00 B3              mov     dptr,   #serial_tx
000F: 85 82 32              mov     OUT,    DPL
0012: 85 83 33              mov     OUT+1,  DPH
                   
                   ; *** test/memory.asm ***
                   
0015: 11 A9                 acall   serial_init
                   
                            ; use xram
0017: E5 8E                 mov     a,auxr
0019: 55 E1                 anl     a,0xe1  ; clear extram, xrs0-2
001B: 45 10                 orl     a,0x10  ; set xrs2 (size 1792 bytes)
001D: F5 8E                 mov     auxr,a
                   
                            ; initialize memory list
001F: 90 00 00              mov     dptr,#0000
0022: 85 82 38              mov     memory_list,dpl
0025: 85 83 39              mov     memory_list+1,dph
                            ; list head: pointer to first block
0028: 74 04                 mov     a,#4
002A: F5 40                 mov     memory_start,a
002C: F0                    movx    @dptr,a
002D: A3                    inc     dptr
002E: E4                    clr     a
002F: F5 41                 mov     memory_start+1,a
0031: F0                    movx    @dptr,a
0032: A3                    inc     dptr
                            ; max address of allocatable memory: 0x06ff
0033: 75 42 FF              mov     memory_end,#0xff
0036: 85 06 43              mov     memory_end+1,0x06
                            ; amount of free memory: 1792-4 = 1788 = 0x06fc
0039: 74 FC                 mov     a,#0xfc
003B: F0                    movx    @dptr,a
003C: A3                    inc     dptr
003D: 74 06                 mov     a,#0x06
003F: F0                    movx    @dptr,a
0040: A3                    inc     dptr
                            ; first entry: pointer to next (null initially)
0041: E4                    clr     a
0042: F0                    movx    @dptr,a
0043: A3                    inc     dptr
0044: F0                    movx    @dptr,a
0045: A3                    inc     dptr
                            ; size of block (same as free memory initially)
0046: 74 FC                 mov     a,#0xfc
0048: F0                    movx    @dptr,a
0049: A3                    inc     dptr
004A: 74 06                 mov     a,#0x06
004C: F0                    movx    @dptr,a
004D: A3                    inc     dptr
                   
                   loop:
004E: 11 C3                 acall   read_char
                   
0050: B4 44 26              cjne    a,#'D',__1
0053: 11 C8                 acall   read_hex_32
0055: 88 34                 mov     stream_in,r0
0057: 89 35                 mov     stream_in+1,r1
0059: 11 C8                 acall   read_hex_32
005B: E8                    mov     a,r0
005C: A8 34                 mov     r0,stream_in
005E: A9 35                 mov     r1,stream_in+1
0060: 7A 00                 mov     r2,#0
0062: 7B 00                 mov     r3,#0
0064: C0 30                 push    in
0066: C0 31                 push    in+1
0068: 90 02 68              mov     dptr,#stream_xram_read
006B: 85 82 30              mov     in,dpl
006E: 85 83 31              mov     in+1,dph
0071: 31 AC                 acall   dump
0073: D0 31                 pop     in+1
0075: D0 30                 pop     in
0077: 80 D5                 sjmp    loop
                   __1:
0079: B4 41 08              cjne    a,#'A',__2
007C: 11 C8                 acall   read_hex_32
007E: 51 8B                 acall   memory_allocate
0080: 31 57                 acall   print_hex_16
0082: 80 1B                 sjmp    next
                   __2:
0084: B4 52 14              cjne    a,#'R',__3
0087: 11 C8                 acall   read_hex_32
0089: E8                    mov     a,r0
008A: FC                    mov     r4,a
008B: E9                    mov     a,r1
008C: FD                    mov     r5,a
008D: 11 C8                 acall   read_hex_32
008F: E8                    mov     a,r0
0090: FA                    mov     r2,a
0091: E9                    mov     a,r1
0092: FB                    mov     r3,a
0093: EC                    mov     a,r4
0094: F8                    mov     r0,a
0095: ED                    mov     a,r5
0096: F9                    mov     r1,a
0097: 71 50                 acall   memory_release
0099: 80 04                 sjmp    next
                   __3:
009B: 74 3F                 mov     a,#'?'
009D: 31 27                 acall   print_char
                   next:
009F: 74 0D                 mov     a,#13
00A1: 31 27                 acall   print_char
00A3: 74 0A                 mov     a,#10
00A5: 31 27                 acall   print_char
00A7: 80 A5                 sjmp    loop
                   
                   
                   ; *********************
                   ; * Library Functions *
                   ; *********************
                   
                   ; *** serial/init.inc ***
                   
                   ; >> void serial_init() <<
                   
                   ; Initialize serial interface.
                   ; - assumes 20MHz clock and X2 mode
                   ; - uses internal baud rate generator
                   ; - speed: 9600 bits per second
                   ; Formula: BRL = 256 - (F_clk / (32 * Baud_Rate))
                   ; ---
                   ; See datasheet page 52 for details,
                   ; also note oscillator diagram on page 16!
                   
                   serial_init:
00A9: 75 98 52              mov     SCON,   #0x52   ; SM1, REN, TI
00AC: 75 9A BF              mov     BRL,    #191    ; 9600 @20MHz CLK
00AF: 75 9B 1E              mov     BDRCON, #0x1e   ; BRR, RBCK, TBCK, SPD
00B2: 22                    ret
                   
                   ; *** serial/tx.inc ***
                   
                   ; >> void serial_tx(char a) <<
                   
                   ; Transmit byte from accumulator.
                   
                   serial_tx:
00B3: 30 99 FD              jnb     TI,     serial_tx
00B6: C2 99                 clr     TI
00B8: F5 99                 mov     SBUF,   a
00BA: 22                    ret
                   
                   ; *** serial/rx.inc ***
                   
                   ; >> char serial_rx <<
                   
                   ; Receive byte into accumulator.
                   
                   serial_rx:
00BB: 30 98 FD              jnb     RI,     serial_rx
00BE: C2 98                 clr     RI
00C0: E5 99                 mov     a,      SBUF
00C2: 22                    ret
                   
                   ; *** read/char.inc ***
                   
                   ; >> char read_char() <<
                   
                   ; Read char into accumulator.
                   ; Indirect call to function behind IN pointer.
                   
                   read_char:
00C3: C0 30                 push    IN
00C5: C0 31                 push    IN+1
00C7: 22                    ret
                   
                   ; *** read/char.inc ***
                   
                   ; >> uint32 read_hex_32() <<
                   
                   ; Read 32 bit hex integer from input into r0-r3.
                   ; Stops at the first non-hex character or integer overflow.
                   
                   read_hex_32:
00C8: C0 E0                 push    acc
00CA: EC                    mov     a,      r4
00CB: C0 E0                 push    acc
00CD: ED                    mov     a,      r5
00CE: C0 E0                 push    acc
                   
00D0: E4                    clr     a
00D1: F8                    mov     r0,     a
00D2: F9                    mov     r1,     a
00D3: FA                    mov     r2,     a
00D4: FB                    mov     r3,     a
                   
                   read_hex_32__loop:
00D5: 11 C3                 acall   read_char
                   
00D7: C3                    clr     c
00D8: 94 30                 subb    a,      #0x30   ; ascii '0'
00DA: 40 42                 jc      read_hex_32__end
00DC: B4 0A 00              cjne    a,      #10,    read_hex_32__1
                   read_hex_32__1:
00DF: 40 0D                 jc      read_hex_32__3
00E1: 94 11                 subb    a,      #17     ; chars between '0' and 'A'
00E3: 40 39                 jc      read_hex_32__end
00E5: 24 0A                 add     a,      #10
00E7: 54 DF                 anl     a,      #0xdf   ; allow lowercase
00E9: B4 10 00              cjne    a,      #0x10,  read_hex_32__2
                   read_hex_32__2:
00EC: 50 30                 jnc     read_hex_32__end
                   
                   read_hex_32__3:
00EE: FC                    mov     r4,     a
00EF: E8                    mov     a,      r0
00F0: C4                    swap    a
00F1: FD                    mov     r5,     a
00F2: 54 F0                 anl     a,      #0xf0
00F4: 4C                    orl     a,      r4
00F5: F8                    mov     r0,     a
00F6: ED                    mov     a,      r5
00F7: 54 0F                 anl     a,      #0x0f
                   
00F9: FC                    mov     r4,     a
00FA: E9                    mov     a,      r1
00FB: C4                    swap    a
00FC: FD                    mov     r5,     a
00FD: 54 F0                 anl     a,      #0xf0
00FF: 4C                    orl     a,      r4
0100: F9                    mov     r1,     a
0101: ED                    mov     a,      r5
0102: 54 0F                 anl     a,      #0x0f
                   
0104: FC                    mov     r4,     a
0105: EA                    mov     a,      r2
0106: C4                    swap    a
0107: FD                    mov     r5,     a
0108: 54 F0                 anl     a,      #0xf0
010A: 4C                    orl     a,      r4
010B: FA                    mov     r2,     a
010C: ED                    mov     a,      r5
010D: 54 0F                 anl     a,      #0x0f
                   
010F: FC                    mov     r4,     a
0110: EB                    mov     a,      r3
0111: C4                    swap    a
0112: FD                    mov     r5,     a
0113: 54 F0                 anl     a,      #0xf0
0115: 4C                    orl     a,      r4
0116: FB                    mov     r3,     a
0117: ED                    mov     a,      r5
0118: 54 0F                 anl     a,      #0x0f
                   
011A: 70 02                 jnz     read_hex_32__end        ; overflow
011C: 80 B7                 sjmp    read_hex_32__loop
                   
                   
                   read_hex_32__end:
011E: D0 E0                 pop     acc
0120: FD                    mov     r5,     a
0121: D0 E0                 pop     acc
0123: FC                    mov     r4,     a
0124: D0 E0                 pop     acc
0126: 22                    ret
                   
                   ; *** print/char.inc ***
                   
                   ; >> void print_char(char a) <<
                   
                   ; Print char from accumulator.
                   ; Indirect call to function behind OUT pointer.
                   
                   print_char:
0127: C0 32                 push    OUT
0129: C0 33                 push    OUT+1
012B: 22                    ret
                   
                   ; *** print/text.inc ***
                   
                   ; >> void print_text(char* dptr) <<
                   
                   ; Print null-terminated string from program code.
                   ; Aborts if no null terminator is found after 256 bytes.
                   
                   print_text:
012C: C0 E0                 push    ACC
012E: E8                    mov     a,      r0
012F: C0 E0                 push    ACC
                   
0131: E4                    clr     a
0132: F8                    mov     r0,     a
                   print_text__loop:
0133: 93                    movc    a,      @dptr+a
0134: 60 06                 jz      print_text__end
0136: 31 27                 acall   print_char
0138: 08                    inc     r0
0139: E8                    mov     a,      r0
013A: 70 F7                 jnz     print_text__loop
                   
                   print_text__end:
013C: D0 E0                 pop     ACC
013E: F8                    mov     r0,     a
013F: D0 E0                 pop     ACC
0141: 22                    ret
                   
                   ; *** print/hex.inc ***
                   
                   ; >> void print_hex_8(char a) <<
                   
                   ; Print hexadecimal number from accumulator.
                   
                   print_hex_8:
0142: C4                    swap    a       ; high nibble first
0143: 31 46                 acall   print_hex_8__nibble
0145: C4                    swap    a
                   print_hex_8__nibble:
0146: C0 E0                 push    ACC
0148: 54 0F                 anl     a,      #0x0f
014A: 24 90                 add     a,      #0x90
014C: D4                    da      a
014D: 34 40                 addc    a,      #0x40
014F: D4                    da      a
0150: 44 20                 orl     a,      #0x20   ; lower case
0152: 31 27                 acall   print_char
0154: D0 E0                 pop     ACC
0156: 22                    ret
                   
                   ; >> void print_hex_16(int r0r1) <<
                   
                   ; Print hexadecimal number from r0-r1.
                   
                   print_hex_16:
0157: C0 E0                 push    ACC
0159: E9                    mov     a,      r1      ; MSB first
015A: 31 42                 acall   print_hex_8
015C: E8                    mov     a,      r0      ; LSB second
015D: 31 42                 acall   print_hex_8
015F: D0 E0                 pop     ACC
0161: 22                    ret
                   
                   ; >> void print_hex_32(long r0r1r2r3) <<
                   
                   ; Print hexadecimal number from r0-r3.
                   
                   print_hex_32:
0162: C0 E0                 push    ACC
0164: EB                    mov     a,      r3      ; MSB first
0165: 31 42                 acall   print_hex_8
0167: EA                    mov     a,      r2
0168: 31 42                 acall   print_hex_8
016A: E9                    mov     a,      r1
016B: 31 42                 acall   print_hex_8
016D: E8                    mov     a,      r0      ; LSB last
016E: 31 42                 acall   print_hex_8
0170: D0 E0                 pop     ACC
0172: 22                    ret
                   
                   ; *** util/xch.inc ***
                   
                   ; >> void xch_r0123_r4567(uint32 &r0r1r2r3, uint32 &r4r5r6r7
                   
                   ; Exchange registers r0-r3 with r4-r7.
                   
                   xch_r0123_r4567:
                            ; r0 <-> r4
0173: C8                    xch     a,      r0
0174: CC                    xch     a,      r4
0175: C8                    xch     a,      r0
                            ; r1 <-> r5
0176: C9                    xch     a,      r1
0177: CD                    xch     a,      r5
0178: C9                    xch     a,      r1
                            ; r2 <-> r6
0179: CA                    xch     a,      r2
017A: CE                    xch     a,      r6
017B: CA                    xch     a,      r2
                            ; r3 <-> r7
017C: CB                    xch     a,      r3
017D: CF                    xch     a,      r7
017E: CB                    xch     a,      r3
                            ; a remains unchanged
017F: 22                    ret
                   
                   ; *** util/regbank.inc ***
                   
                   ; >> void* regbank_next() <<
                   
                   ; Switch to next register bank.
                   ; Return pointer to r0 of old bank in new r0.
                   
                   regbank_next:
0180: C0 E0                 push    acc
                            ; check if already at highest bank
0182: E5 D0                 mov     a,      psw
0184: 54 18                 anl     a,      #0x18
0186: B4 18 02              cjne    a,      #0x18,  regbank_next__continue
0189: 91 76                 acall   panic   ; overflow
                   regbank_next__continue:
                            ; switch to next bank
018B: E5 D0                 mov     a,      psw
018D: 24 08                 add     a,      #0x08
018F: F5 D0                 mov     psw,    a
                            ; calculate pointer to old bank
0191: 54 18                 anl     a,      #0x18
0193: 24 F8                 add     a,      #0xf8
0195: F8                    mov     r0,     a
                            ; done
0196: D0 E0                 pop     acc
0198: 22                    ret
                   
                   ; >> void regbank_prev() <<
                   
                   ; Switch to previous register bank.
                   
                   regbank_prev:
0199: C0 E0                 push    acc
                            ; check if already at lowest bank
019B: E5 D0                 mov     a,      psw
019D: 54 18                 anl     a,      #0x18
019F: 70 02                 jnz     regbank_prev__continue
01A1: 91 76                 acall   panic   ; underflow
                   regbank_prev__continue:
                            ; switch to previous bank
01A3: E5 D0                 mov     a,      psw
01A5: 24 F8                 add     a,      #0xf8
01A7: F5 D0                 mov     psw,    a
                            ; done
01A9: D0 E0                 pop     acc
01AB: 22                    ret
                   
                   ; *** util/dump.inc ***
                   
                   ; >> void dump(uint32 &r0r1r2r3, uint8 a) <<
                   
                   ; Print hexdump from standard input to standard output.
                   ; Starting value for address column in r0-r3.
                   ; Number of bytes to print in a (0 means 256).
                   ; r0-r4 contains next address upon exit.
                   
                   dump:
01AC: C0 F0                 push    b
01AE: C0 E0                 push    acc
01B0: F5 F0                 mov     b,      a
01B2: EC                    mov     a,      r4
01B3: C0 E0                 push    acc
01B5: ED                    mov     a,      r5
01B6: C0 E0                 push    acc
01B8: EE                    mov     a,      r6
01B9: C0 E0                 push    acc
01BB: EF                    mov     a,      r7
01BC: C0 E0                 push    acc
                   
                            ; b: total bytes remaining
                            ; r0: buffer pointer
                            ; r1: read loop counter / padding size
                            ; r2: print loop counter
                   
                            ; r4-7: address label
01BE: 31 73                 acall   xch_r0123_r4567
                   
                            ; allocate 16 byte array on stack
01C0: E5 81                 mov     a,      sp
01C2: F8                    mov     r0,     a
01C3: 24 10                 add     a,      #16
01C5: F5 81                 mov     sp,     a
                   
                   dump__line_loop:
                            ; read into buffer
01C7: 79 10                 mov     r1,     #16
                   dump__read_loop:
01C9: 11 C3                 acall   read_char
01CB: 08                    inc     r0
01CC: F6                    mov     @r0,    a
01CD: D5 F0 03              djnz    b,      dump__read_continue
01D0: 19                    dec     r1
01D1: 80 02                 sjmp    dump__read_end
                   dump__read_continue:
01D3: D9 F4                 djnz    r1,     dump__read_loop
                   dump__read_end:
                   
                            ; print address column
01D5: 31 73                 acall   xch_r0123_r4567
01D7: 31 62                 acall   print_hex_32
01D9: 31 73                 acall   xch_r0123_r4567
01DB: 74 3A                 mov     a,      #':'
01DD: 31 27                 acall   print_char
                   
                            ; if r1 is nonzero here, we have a shorter line
                            ; the value in r1 is the number of padding bytes
                   
                            ; wind back pointer
01DF: E8                    mov     a,      r0
01E0: 24 F0                 add     a,      #-16
01E2: 29                    add     a,      r1
01E3: F8                    mov     r0,     a
                   
                            ; print hex
01E4: 7A 10                 mov     r2,     #16
                   dump__print_hex_loop:
01E6: 08                    inc     r0
01E7: EA                    mov     a,      r2
01E8: 54 03                 anl     a,      #3      ; mod 4
01EA: 70 04                 jnz     dump__print_hex_no_gap
01EC: 74 20                 mov     a,      #' ' ; gap after every 4 bytes
01EE: 31 27                 acall   print_char
                   dump__print_hex_no_gap:
01F0: EA                    mov     a,      r2
01F1: D3                    setb    c
01F2: 99                    subb    a,      r1
01F3: 50 08                 jnc     dump__print_hex_no_padding
01F5: 74 20                 mov     a,      #' ' ; padding for shorter line
01F7: 31 27                 acall   print_char
01F9: 31 27                 acall   print_char
01FB: 80 03                 sjmp    dump__print_hex_next
                   dump__print_hex_no_padding:
01FD: E6                    mov     a,      @r0
01FE: 31 42                 acall   print_hex_8
                   dump__print_hex_next:
0200: 74 20                 mov     a,      #' ' ; space between bytes
0202: 31 27                 acall   print_char
0204: DA E0                 djnz    r2,     dump__print_hex_loop
                   
                            ; wind back again
0206: E8                    mov     a,      r0
0207: 24 F0                 add     a,      #-16
0209: F8                    mov     r0,     a
                   
                            ; print ascii
020A: 74 20                 mov     a,      #' '
020C: 31 27                 acall   print_char
020E: 74 7C                 mov     a,      #'|'
0210: 31 27                 acall   print_char
0212: 74 10                 mov     a,      #16
0214: C3                    clr     c
0215: 99                    subb    a,      r1
0216: F9                    mov     r1,     a ; number of bytes to print
0217: FA                    mov     r2,     a
                   dump__print_ascii_loop:
0218: 08                    inc     r0
0219: E6                    mov     a,      @r0
021A: B4 20 00              cjne    a,      #0x20,  dump__print_ascii_check1
                   dump__print_ascii_check1:
021D: 40 05                 jc      dump__print_ascii_replace
021F: B4 7F 00              cjne    a,      #0x7f,  dump__print_ascii_check2
                   dump__print_ascii_check2:
0222: 40 02                 jc      dump__print_ascii_continue
                   dump__print_ascii_replace:
0224: 74 2E                 mov     a,      #'.'
                   dump__print_ascii_continue:
0226: 31 27                 acall   print_char
0228: DA EE                 djnz    r2,     dump__print_ascii_loop
022A: 74 7C                 mov     a,      #'|'
022C: 31 27                 acall   print_char
022E: 74 0D                 mov     a,      #13
0230: 31 27                 acall   print_char
0232: 74 0A                 mov     a,      #10
0234: 31 27                 acall   print_char
                   
                            ; wind back again
0236: E8                    mov     a,      r0
0237: 24 F0                 add     a,      #-16
0239: F8                    mov     r0,     a
                   
                            ; next address
023A: EC                    mov     a,      r4
023B: 29                    add     a,      r1
023C: FC                    mov     r4,     a
023D: ED                    mov     a,      r5
023E: 34 00                 addc    a,      #0
0240: FD                    mov     r5,     a
0241: EE                    mov     a,      r6
0242: 34 00                 addc    a,      #0
0244: FE                    mov     r6,     a
0245: EF                    mov     a,      r7
0246: 34 00                 addc    a,      #0
0248: FF                    mov     r7,     a
                   
0249: E5 F0                 mov     a,      b
024B: 60 02                 jz      dump__end
024D: 21 C7                 ajmp    dump__line_loop
                   
                   dump__end:
                            ; deallocate array from stack
024F: E5 81                 mov     a,      sp
0251: 24 F0                 add     a,      #-16
0253: F5 81                 mov     sp,     a
                   
0255: 31 73                 acall   xch_r0123_r4567
                   
0257: D0 E0                 pop     acc
0259: FF                    mov     r7,     a
025A: D0 E0                 pop     acc
025C: FE                    mov     r6,     a
025D: D0 E0                 pop     acc
025F: FD                    mov     r5,     a
0260: D0 E0                 pop     acc
0262: FC                    mov     r4,     a
0263: D0 E0                 pop     acc
0265: D0 F0                 pop     b
0267: 22                    ret
                   
                   ; *** stream/xram_read.inc ***
                   
                   ; >> char stream_xram_read() <<
                   
                   ; Read byte from on-chip expanded RAM at stream input pointe
                   ; 16 bit value of the stream pointer is used and incremented
                   
                   stream_xram_read:
0268: C0 8E                 push    auxr
026A: C0 82                 push    dpl
026C: C0 83                 push    dph
                   
026E: E5 8E                 mov     a,      auxr
0270: 55 E1                 anl     a,      0xe1    ; clear extram, xrs0-2
0272: 45 10                 orl     a,      0x10    ; set xrs2 (size 1792 bytes
0274: F5 8E                 mov     auxr,   a
                   
0276: 85 34 82              mov     dpl,    stream_in
0279: 85 35 83              mov     dph,    stream_in+1
                   
027C: E0                    movx    a,      @dptr
027D: A3                    inc     dptr
027E: 85 82 34              mov     stream_in,      dpl
0281: 85 83 35              mov     stream_in+1,    dph
                   
0284: D0 83                 pop     dph
0286: D0 82                 pop     dpl
0288: D0 8E                 pop     auxr
028A: 22                    ret
                   
                   ; *** memory/allocate.inc ***
                   
                   ; >> r0r1 *memory_allocate(r0r1 size) <<
                   
                   ; Allocate memory, return lowest address
                   
                   memory_allocate:
028B: C0 A8                 push    ie
028D: C2 AF                 clr     ea
                   
028F: C0 E0                 push    acc
0291: C0 82                 push    dpl
0293: C0 83                 push    dph
                   
0295: 31 80                 acall   regbank_next
0297: E6                    mov     a,@r0
0298: FE                    mov     r6,a
0299: 08                    inc     r0
029A: E6                    mov     a,@r0
029B: FF                    mov     r7,a ; size param now in r6r7
                   
029C: EE                    mov     a,r6
029D: 4F                    orl     a,r7
029E: 70 02                 jnz     memory_allocate__0
02A0: 91 76                 acall   panic   ; invalid size (0)
                   
                   memory_allocate__0:
                            ; rounding to next multiple of 4
02A2: EE                    mov     a,r6
02A3: 24 03                 add     a,#3
02A5: 54 FC                 anl     a,#0xfc
02A7: FE                    mov     r6,a
02A8: EF                    mov     a,r7
02A9: 34 00                 addc    a,#0
02AB: FF                    mov     r7,a
                   
                            ; set prev (r2,r3) and curr (r4r5) pointers
02AC: AA 38                 mov     r2,memory_list
02AE: AB 39                 mov     r3,memory_list+1
02B0: 8A 82                 mov     dpl,r2
02B2: 8B 83                 mov     dph,r3
02B4: E0                    movx    a,@dptr
02B5: FC                    mov     r4,a
02B6: A3                    inc     dptr
02B7: E0                    movx    a,@dptr
02B8: FD                    mov     r5,a
                   
                   memory_allocate__loop:
02B9: EC                    mov     a,r4
02BA: 4D                    orl     a,r5
02BB: 70 02                 jnz     memory_allocate__0a
02BD: 91 76                 acall   panic   ; no large enough free block found
                   memory_allocate__0a:
                            ; compare curr->size with required size
02BF: 8C 82                 mov     dpl,r4
02C1: 8D 83                 mov     dph,r5
02C3: A3                    inc     dptr
02C4: A3                    inc     dptr    ; dptr is now &(curr->size)
02C5: E0                    movx    a,@dptr
02C6: F9                    mov     r1,a    ; store low byte for later (cannot 
02C7: A3                    inc     dptr    ; compare high byte first
02C8: C3                    clr     c
02C9: E0                    movx    a,@dptr
02CA: 9F                    subb    a,r7
02CB: 70 1C                 jnz     memory_allocate__1
02CD: E9                    mov     a,r1
02CE: 9E                    subb    a,r6
02CF: 70 18                 jnz     memory_allocate__1
                   
                            ; block size is exact match
02D1: 8A 82                 mov     dpl,r2  ; prev
02D3: 8B 83                 mov     dph,r3
02D5: 05 A2                 inc     auxr1   ;*switch data pointers
02D7: 8C 82                 mov     dpl,r4  ; curr
02D9: 8D 83                 mov     dph,r5
                            ; prev->next = curr->next
02DB: E0                    movx    a,@dptr
02DC: A3                    inc     dptr
02DD: 05 A2                 inc     auxr1   ;*
02DF: F0                    movx    @dptr,a
02E0: A3                    inc     dptr
02E1: 05 A2                 inc     auxr1   ;*
02E3: E0                    movx    a,@dptr
02E4: 05 A2                 inc     auxr1   ;*
02E6: F0                    movx    @dptr,a
02E7: 80 47                 sjmp    memory_allocate__success
                   
                   memory_allocate__1:
02E9: 50 0F                 jnc     memory_allocate__2 ; jump if curr is larger
                            ; too small, move on to next entry in list
02EB: EC                    mov     a,r4    ; -.
02EC: FA                    mov     r2,a    ;  |- prev = curr
02ED: ED                    mov     a,r5    ;  |
02EE: FB                    mov     r3,a    ; -'
02EF: 8C 82                 mov     dpl,r4  ; -.
02F1: 8D 82                 mov     dpl,r5  ;  |
02F3: E0                    movx    a,@dptr ;  |
02F4: FC                    mov     r4,a    ;  |- curr = curr->next
02F5: A3                    inc     dptr    ;  |
02F6: E0                    movx    a,@dptr ;  |
02F7: FD                    mov     r5,a    ; -'
02F8: 80 BF                 sjmp    memory_allocate__loop
                   
                   memory_allocate__2:
                            ; split big block
02FA: 8A 82                 mov     dpl,r2  ; prev
02FC: 8B 83                 mov     dph,r3  ;
02FE: EC                    mov     a,r4    ; -.
02FF: 2E                    add     a,r6    ;  |
0300: FA                    mov     r2,a    ;  |
0301: F0                    movx    @dptr,a ;  |
0302: A3                    inc     dptr    ;  |- prev->next = curr+size
0303: ED                    mov     a,r5    ;  |               '---.---'
0304: 3F                    addc    a,r7    ;  |  pointer to leftover block
0305: FB                    mov     r3,a    ;  |  also gets stored in r2r3
0306: F0                    movx    @dptr,a ; -' (prev is not needed anymore)
                   
0307: 8A 82                 mov     dpl,r2  ; leftover
0309: 8B 83                 mov     dph,r3
030B: 05 A2                 inc     auxr1   ;*switch data pointers
030D: 8C 82                 mov     dpl,r4  ; curr
030F: 8D 83                 mov     dph,r5
0311: E0                    movx    a,@dptr         ; -.
0312: A3                    inc     dptr    ;  |
0313: 05 A2                 inc     auxr1   ;* |
0315: F0                    movx    @dptr,a ;  |
0316: A3                    inc     dptr    ;  |
0317: 05 A2                 inc     auxr1   ;* |- leftover->next = curr->next
0319: E0                    movx    a,@dptr ;  |
031A: A3                    inc     dptr    ;  |
031B: 05 A2                 inc     auxr1   ;* |
031D: F0                    movx    @dptr,a ;  |
031E: A3                    inc     dptr    ; -'
                            ; data pointers are now &(leftover->size) and &(cur
031F: 05 A2                 inc     auxr1   ;*-.
0321: E0                    movx    a,@dptr ;  |
0322: A3                    inc     dptr    ;  |
0323: C3                    clr     c       ;  |
0324: 9E                    subb    a,r6    ;  |
0325: 05 A2                 inc     auxr1   ;* |
0327: F0                    movx    @dptr,a ;  |- leftover->size = curr->size -
0328: A3                    inc     dptr    ;  |
0329: 05 A2                 inc     auxr1   ;* |
032B: E0                    movx    a,@dptr ;  |
032C: 9F                    subb    a,r7    ;  |
032D: 05 A2                 inc     auxr1   ;* |
032F: F0                    movx    @dptr,a ; -'
                   
                   memory_allocate__success:
0330: 85 38 82              mov     dpl,memory_list
0333: 85 39 83              mov     dph,memory_list+1
0336: A3                    inc     dptr    ; -.
0337: A3                    inc     dptr    ;  |
0338: E0                    movx    a,@dptr ;  |
0339: C3                    clr     c       ;  |
033A: 9E                    subb    a,r6    ;  |- memory_list->free -= size
033B: F0                    movx    @dptr,a ;  |
033C: A3                    inc     dptr    ;  |
033D: E0                    movx    a,@dptr ;  |
033E: 9F                    subb    a,r7    ;  |
033F: F0                    movx    @dptr,a ; -'
                   
0340: ED                    mov     a,r5    ; -.
0341: F6                    mov     @r0,a   ;  |
0342: 18                    dec     r0      ;  |- return curr
0343: EC                    mov     a,r4    ;  |
0344: F6                    mov     @r0,a   ; -'
                   
0345: 31 99                 acall   regbank_prev
0347: D0 83                 pop     dph
0349: D0 82                 pop     dpl
034B: D0 E0                 pop     acc
                   
034D: D0 A8                 pop     ie
034F: 22                    ret
                   
                   ; *** memory/release.inc ***
                   
                   ; >> void release(r0r1 *addr, r2r3 size) <<
                   
                   ; Allocate memory, return lowest address
                   
                   memory_release:
0350: C0 A8                 push    ie
0352: C2 AF                 clr     ea
                            
0354: C0 E0                 push    acc
0356: C0 82                 push    dpl
0358: C0 83                 push    dph
                   
035A: 31 80                 acall   regbank_next
                   
035C: E8                    mov     a,r0
035D: 24 03                 add     a,#3
035F: F8                    mov     r0,a
                            ; r6r7 <- size
0360: E6                    mov     a,@r0
0361: FF                    mov     r7,a
0362: 18                    dec     r0
0363: E6                    mov     a,@r0
0364: FE                    mov     r6,a
0365: 18                    dec     r0
                            ; r0r1 <- pointer to block
0366: E6                    mov     a,@r0
0367: F9                    mov     r1,a
0368: 18                    dec     r0
0369: E6                    mov     a,@r0
036A: F8                    mov     r0,a
                   
                            ; input parameter check
036B: EE                    mov     a,r6
036C: 4F                    orl     a,r7
036D: 70 02                 jnz     memory_release__1
036F: 91 76                 acall   panic   ; invalid size (0)
                   memory_release__1:
0371: E9                    mov     a,r1
0372: B5 41 04              cjne    a,memory_start+1,memory_release__2
0375: E8                    mov     a,r0
0376: B5 40 00              cjne    a,memory_start,memory_release__2
                   memory_release__2:
0379: 50 02                 jnc     memory_release__3
037B: 91 76                 acall   panic   ; invalid address (< memory_start)
                   memory_release__3:
037D: E9                    mov     a,r1
037E: B5 43 04              cjne    a,memory_end+1,memory_release__4
0381: E8                    mov     a,r0
0382: B5 42 00              cjne    a,memory_end,memory_release__4
                   memory_release__4:
0385: 40 02                 jc      memory_release__5
0387: 91 76                 acall   panic   ; invalid address (>= memory_end)
                   memory_release__5:
                   
                            ; rounding
0389: EE                    mov     a,r6
038A: 24 03                 add     a,#3
038C: 54 FC                 anl     a,#0xfc
038E: FE                    mov     r6,a
038F: EF                    mov     a,r7
0390: 34 00                 addc    a,#0
0392: FF                    mov     r7,a
                   
                            ; find position in list
                            ; r2r3: prev pointer
                            ; r4r5: next pointer
0393: AA 38                 mov     r2,memory_list
0395: AB 39                 mov     r3,memory_list+1
0397: 8A 82                 mov     dpl,r2
0399: 8B 83                 mov     dph,r3
039B: E0                    movx    a,@dptr
039C: FC                    mov     r4,a
039D: A3                    inc     dptr
039E: E0                    movx    a,@dptr
039F: FD                    mov     r5,a
                   memory_release__loop:
03A0: EC                    mov     a,r4
03A1: 4D                    orl     a,r5
03A2: 60 1C                 jz      memory_release__7       ; next == null
03A4: C3                    clr     c
03A5: ED                    mov     a,r5
03A6: 99                    subb    a,r1
03A7: 70 06                 jnz     memory_release__6
03A9: EC                    mov     a,r4
03AA: 98                    subb    a,r0
03AB: 70 02                 jnz     memory_release__6
03AD: 91 76                 acall   panic   ; double free   (next == block)
                   memory_release__6:
03AF: 50 0F                 jnc     memory_release__7       ; next > block
03B1: EC                    mov     a,r4    ; -.
03B2: FA                    mov     r2,a    ;  |- prev = next
03B3: ED                    mov     a,r5    ;  |
03B4: FB                    mov     r3,a    ; -'
03B5: 8C 82                 mov     dpl,r4  ; -.
03B7: 8D 83                 mov     dph,r5  ;  |
03B9: E0                    movx    a,@dptr ;  |
03BA: FC                    mov     r4,a    ;  |- next = next->next
03BB: A3                    inc     dptr    ;  |
03BC: E0                    movx    a,@dptr ;  |
03BD: FD                    mov     r5,a    ; -'
                   
03BE: 80 E0                 sjmp    memory_release__loop
                   
                   memory_release__7:
                            ; if (prev == memory_list) ...
03C0: EB                    mov     a,r3
03C1: B5 39 06              cjne    a,memory_list+1,memory_release__8
03C4: EA                    mov     a,r2
03C5: B5 38 02              cjne    a,memory_list,memory_release__8
03C8: 80 30                 sjmp    memory_release__link_new ; ... link as new 
                            ; ... else:
                   memory_release__8:
                            ; compute top of previous block
03CA: 8A 82                 mov     dpl,r2
03CC: 8B 83                 mov     dph,r3
03CE: A3                    inc     dptr
03CF: A3                    inc     dptr    ; prev->size
                            ; top = prev + prev->size
03D0: E0                    movx    a,@dptr
03D1: 2A                    add     a,r2
03D2: C0 E0                 push    acc     ;-.
03D4: A3                    inc     dptr    ; |
03D5: E0                    movx    a,@dptr ; |
03D6: 3B                    addc    a,r3    ; |
03D7: F5 83                 mov     dph,a   ; |
03D9: D0 82                 pop     dpl     ;<' dptr = top
                   
                            ; if (block == top) ...
03DB: E9                    mov     a,r1
03DC: B5 83 17              cjne    a,dph,memory_release__9
03DF: E8                    mov     a,r0
03E0: B5 82 13              cjne    a,dpl,memory_release__9
                            ; ... coalsece with previous block ...
03E3: 8A 82                 mov     dpl,r2
03E5: 8B 83                 mov     dph,r3
03E7: A3                    inc     dptr
03E8: A3                    inc     dptr    ; prev->size
03E9: E0                    movx    a,@dptr ; -.
03EA: 2E                    add     a,r6    ;  |- += size
03EB: F0                    movx    @dptr,a ;  |
03EC: A3                    inc     dptr    ;  |
03ED: E0                    movx    a,@dptr ;  |
03EE: 3F                    addc    a,r7    ;  |
03EF: F0                    movx    @dptr,a ; -'
03F0: EA                    mov     a,r2    ; -.
03F1: F8                    mov     r0,a    ;  |- block = prev
03F2: EB                    mov     a,r3    ;  |
03F3: F9                    mov     r1,a    ; -'
03F4: 80 1C                 sjmp    memory_release__10
                            ; ... else:
                   memory_release__9:
03F6: 50 02                 jnc     memory_release__link_new ; ... link as new 
03F8: 91 76                 acall   panic   ; error: block < top (overlap)
                   
                   memory_release__link_new:
                            ; link into list as new node
03FA: 88 82                 mov     dpl,r0  ; -.
03FC: 89 83                 mov     dph,r1  ;  |
03FE: EC                    mov     a,r4    ;  |
03FF: F0                    movx    @dptr,a ;  |- block->next = next
0400: A3                    inc     dptr    ;  |
0401: ED                    mov     a,r5    ;  |
0402: F0                    movx    @dptr,a ; -'
0403: A3                    inc     dptr    ; -.
0404: EE                    mov     a,r6    ;  |
0405: F0                    movx    @dptr,a ;  |- block->size = size
0406: A3                    inc     dptr    ;  |
0407: EF                    mov     a,r7    ;  |
0408: F0                    movx    @dptr,a ; -'
0409: 8A 82                 mov     dpl,r2  ; -.
040B: 8B 83                 mov     dph,r3  ;  |
040D: E8                    mov     a,r0    ;  |
040E: F0                    movx    @dptr,a ;  |- prev->next = block
040F: A3                    inc     dptr    ;  |
0410: E9                    mov     a,r1    ;  |
0411: F0                    movx    @dptr,a ; -'
                            ; last use of prev in r2r3
                   
                   memory_release__10:
                            ; check if block is touching next block
0412: 88 82                 mov     dpl,r0
0414: 89 83                 mov     dph,r1
0416: A3                    inc     dptr
0417: A3                    inc     dptr    ; block->size
0418: E0                    movx    a,@dptr
0419: 28                    add     a,r0
041A: FA                    mov     r2,a    ; r2 used as temp storage here
041B: A3                    inc     dptr
041C: E0                    movx    a,@dptr
041D: 39                    addc    a,r1
041E: F5 83                 mov     dph,a
0420: 8A 82                 mov     dpl,r2 ; dptr: block + block->size
                   
0422: ED                    mov     a,r5
0423: B5 83 32              cjne    a,dph,memory_release__11
0426: EC                    mov     a,r4
0427: B5 82 2E              cjne    a,dpl,memory_release__11
                   
                            ; coalesce with next block
042A: 88 82                 mov     dpl,r0  ; -.
042C: 89 83                 mov     dph,r1  ;  |
042E: 05 A2                 inc     auxr1   ; *|
0430: 8C 82                 mov     dpl,r4  ;  |
0432: 8D 83                 mov     dph,r5  ;  |
0434: E0                    movx    a,@dptr ;  |
0435: A3                    inc     dptr    ;  |
0436: 05 A2                 inc     auxr1   ;* |- block->next = next->next
0438: F0                    movx    @dptr,a ;  |
0439: A3                    inc     dptr    ;  |
043A: 05 A2                 inc     auxr1   ; *|
043C: E0                    movx    a,@dptr ;  |
043D: A3                    inc     dptr    ;  |
043E: 05 A2                 inc     auxr1   ;* |
0440: F0                    movx    @dptr,a ; -'
0441: A3                    inc     dptr    ; -.
0442: 05 A2                 inc     auxr1   ; *|
0444: E0                    movx    a,@dptr ;  |
0445: A3                    inc     dptr    ;  |
0446: FA                    mov     r2,a    ;  |
0447: 05 A2                 inc     auxr1   ;* |
0449: E0                    movx    a,@dptr ;  |
044A: 2A                    add     a,r2    ;  |
044B: F0                    movx    @dptr,a ;  |- block->size += next->size
044C: A3                    inc     dptr    ;  |
044D: 05 A2                 inc     auxr1   ; *|
044F: E0                    movx    a,@dptr ;  |
0450: FB                    mov     r3,a    ;  |
0451: 05 A2                 inc     auxr1   ;* |
0453: E0                    movx    a,@dptr ;  |
0454: 3B                    addc    a,r3    ;  |
0455: F0                    movx    @dptr,a ; -'
0456: 80 04                 sjmp    memory_release__end
                   
                   memory_release__11:
0458: 50 02                 jnc     memory_release__end
045A: 91 76                 acall   panic   ; error: next < block+block->size
                   
                   memory_release__end:
045C: 85 38 82              mov     dpl,memory_list
045F: 85 39 83              mov     dph,memory_list+1
0462: A3                    inc     dptr
0463: A3                    inc     dptr
0464: E0                    movx    a,@dptr
0465: 2E                    add     a,r6
0466: F0                    movx    @dptr,a
0467: A3                    inc     dptr
0468: E0                    movx    a,@dptr
0469: 3F                    addc    a,r7
046A: F0                    movx    @dptr,a
                   
046B: 31 99                 acall   regbank_prev
046D: D0 83                 pop     dph
046F: D0 82                 pop     dpl
0471: D0 E0                 pop     acc
0473: D0 A8                 pop     ie
0475: 22                    ret
                   
0476:              .equ panic_out, serial_tx
                   
                   ; *** panic/panic.inc ***
                   
                   ; >> void panic() <<
                   
                   ; Unrecoverable error handler.
                   ; Print caller address and halt.
                   
                   panic:
0476: C2 AF                 clr     ea      ; disable interrupts
0478: 90 00 B3              mov     dptr,   #panic_out
047B: 85 82 32              mov     out,    dpl
047E: 85 83 33              mov     out+1,  dph
0481: 90 04 90              mov     dptr,   #panic_text
0484: 31 2C                 acall   print_text
0486: D0 E0                 pop     acc
0488: 31 42                 acall   print_hex_8
048A: D0 E0                 pop     acc
048C: 31 42                 acall   print_hex_8
048E: 80 FE                 sjmp    *
                   
                   panic_text:
0490: 0D 0A                 .db     13, 10
0492: 20 21 21 21 
      20 70 61 6E 
      69 63 20 40 
                            .db     " !!! panic @"
049E: 00                    .db     0
