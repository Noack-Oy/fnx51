                   
                   ; *** headers ***
                   
                   
                   ; *** global/variables.equ ***
                   
                   ; variables in internal ram
                   
0000:              .equ    in,     0x30    ; pointer to input code
0000:              .equ    out,    0x32    ; pointer to ouput code
                   
0000:              .equ    stream_in,      0x34    ; input stream position
0000:              .equ    stream_out,     0x36    ; output stream position
                   
0000:              .equ    memory_list,    0x38    ; pointer to heap list head
0000:              .equ    memory_start,   0x40    ; first allocatable address
0000:              .equ    memory_end,     0x42    ; last allocatable address
                   
0000:              .equ    block_read,     0x44    ; pointers to block device d
0000:              .equ    block_write,    0x46    ; code (read and write funct
                   
0000:              .equ    stack,  0x50    ; beginning of stack
                   
                   ; *** serial/sfr.equ ***
                   
                   ; Special function registers for serial interface.
                   ; See chapter 14 of AT89C51ED2 datasheet, page 48ff.
                   
                   ; Internal Baud Rate Generator (BRG), see datasheet page 52.
0000:                      .equ    BRL,    0x9A    ; baud rate reload value
0000:                      .equ    BDRCON, 0x9B    ; BRG control register
                   
                   ; *** spi/sfr.equ ***
                   
                   ; Special function registers for serial peripheral interface
                   ; See chapter 16 of AT89C51ED2 datasheet
                   
0000:              .equ    spcon,  0xc3    ; Serial Peripheral Control Register
0000:              .equ    spsta,  0xc4    ; Serial Peripheral Status Register
0000:              .equ    spdat,  0xc5    ; Serial Peripheral Data Register
                   
                   ; *** sd/config.equ ***
                   
                   ; SPCON register configuration for SD card:
                   ; .-----.-------.-------.-----------------------------------
                   ; | bit | name  | value | remark                            
                   ; |-----|-------|-------|-----------------------------------
                   ; | 7   | SPR2  | 1     | SPR2:0 = 101-> Fclk_periph / 64   
                   ; | 6   | SPEN  | 1     | Set to enable the SPI             
                   ; | 5   | SSDIS | 1     | Set to disable /SS input          
                   ; | 4   | MSTR  | 1     | Set to configure the SPI as a mast
                   ; | 3   | CPOL  | 0     | Cleared to have SCK idle at '0'   
                   ; | 2   | CPHA  | 0     | Cleared to sample on leading edge 
                   ; | 1   | SPR1  | 0     | (see above)                       
                   ; | 0   | SPR0  | 1     | (see above)   speed: 312.5 kHz    
                   ; '-----'-------'-------'-----------------------------------
                   
0000:              .equ    sd_spi_config,  0xf1
                   
0000:              .flag   sd_pin_cs,      p1.1
                   
                   ; *** interrupt vectors ***
                   
0000:              .org 0x0000
0000: 80 4E                sjmp    main
0050:              .org 0x0050
                   
                   ; *** main program ***
                   
                   main:
                   
                   
                   ; *** global/init.inc ***
                   
                   ; Initialize stack pointer and global variables.
                   ; This must be included early in the main program.
                   
0050: 75 81 50             mov     SP,     #STACK
                   
0053: 31 D7                acall   serial_init
0055: 11 B0                acall   sd_init
0057: 51 08                acall   print_hex_8
0059: 51 28                acall   print_hex_32
005B: 11 98                acall   newline
                   
                   ; read a block
005D: 74 11                mov     a,#17
005F: 78 00                mov     r0,#0x00 ; block address
0061: 79 00                mov     r1,#0x00
0063: 7A 00                mov     r2,#0x00
0065: 7B 00                mov     r3,#0x00
0067: 7C 00                mov     r4,#0x00 ; crc, ignored
0069: 31 29                acall   sd_command
                   read_wait:
006B: 31 43                acall   sd_response1
006D: 51 08                acall   print_hex_8
006F: B4 FE F9             cjne    a,#0xfe,read_wait
0072: 11 98                acall   newline
0074: 78 00                mov     r0,#0
                   read_loop: ; 512 bytes (256*2)
0076: 74 FF                mov     a,#0xff
0078: 11 A5                acall   spi_transfer
007A: 51 08                acall   print_hex_8
007C: 74 FF                mov     a,#0xff
007E: 11 A5                acall   spi_transfer
0080: 51 08                acall   print_hex_8
0082: D8 F2                djnz    r0,read_loop
0084: 11 98                acall   newline
                   ; crc
0086: 74 FF                mov     a,#0xff
0088: 11 A5                acall   spi_transfer
008A: 51 08                acall   print_hex_8
008C: 74 FF                mov     a,#0xff
008E: 11 A5                acall   spi_transfer
0090: 51 08                acall   print_hex_8
0092: 11 98                acall   newline
                   
                   abort:
0094: 31 1A                acall   sd_deselect
                   
                   halt:
0096: 80 FE                sjmp    halt
                   
                   newline:
0098: C0 E0                push    acc
009A: 74 0D                mov     a,#13
009C: 51 03                acall   print_char
009E: 74 0A                mov     a,#10
00A0: 51 03                acall   print_char
00A2: D0 E0                pop     acc
00A4: 22                   ret
                   
                   ; *** library ***
                   
                   
                   ; *** spi/transfer.inc ***
                   
                   ; >> char{a} serial_transfer(char{a} data) <<
                   
                   ; SPI transfer function: send byte from a, read response int
                   
                   spi_transfer:
00A5: F5 C5                mov     spdat,a
                   
                   spi_transfer__wait:
00A7: E5 C4                mov     a,spsta
00A9: 54 80                anl     a,#0x80 ;check SPIF bit
00AB: 60 FA                jz      spi_transfer__wait
                   
00AD: E5 C5                mov     a,spdat
00AF: 22                   ret
                   
                   ; *** sd/init.inc ***
                   
                   ; >> uint8{a},uint32{r0-r3} sd_init() <<
                   
                   ; Initialize SD card, return error code in a, OCR in r0-r3.
                   sd_init:
00B0: ED                   mov     a,r5    ; r5 is used as temp store for error
00B1: C0 E0                push    acc
                   
00B3: 75 C3 F1             mov     spcon,#sd_spi_config
00B6: 11 F6                acall   sd_warmup
00B8: 31 0B                acall   sd_select
                   
00BA: 7D 05                mov     r5,#5   ; 5: no idle response to cmd0
00BC: 31 73                acall   sd_cmd0
00BE: B4 01 31             cjne    a,#1,sd_init__end
                   
00C1: 1D                   dec     r5      ; 4: no idle response to cmd8
00C2: 31 83                acall   sd_cmd8
00C4: B4 01 2B             cjne    a,#1,sd_init__end
00C7: 1D                   dec     r5      ; 3: invalid cmd8 response
00C8: BB 00 27             cjne    r3,#0x00,sd_init__end
00CB: BA 00 24             cjne    r2,#0x00,sd_init__end
00CE: B9 01 21             cjne    r1,#0x01,sd_init__end
00D1: B8 AA 1E             cjne    r0,#0xaa,sd_init__end
                   
00D4: 7D 64                mov     r5,#100 ; retry counter
                   sd_init__loop:
00D6: 31 C0                acall   sd_acmd41
00D8: 60 0A                jz      sd_init__continue
00DA: 74 0A                mov     a,#10
00DC: 51 4F                acall   delay_ms_8
00DE: DD F6                djnz    r5,sd_init__loop
00E0: 7D 02                mov     r5,#2   ; 2: acmd41 ready response timeout
00E2: 80 0E                sjmp    sd_init__end
                   
                   sd_init__continue:
00E4: 7D 01                mov     r5,#1   ; 1: no ready response to cmd58
00E6: 31 AC                acall   sd_cmd58
                   
00E8: 1D                   dec     r5      ; 0: success
                   
00E9: 90 65 68             mov     dptr,#sd_block_read
00EC: 85 82 44             mov     block_read,dpl
00EF: 85 83 45             mov     block_read+1,dph
                   
                   sd_init__end:
00F2: D0 E0                pop     acc
00F4: CD                   xch     a,r5
00F5: 22                   ret
                   
                   ; *** sd/warmup.inc ***
                   
                   ; >> void sd_warmup() <<
                   
                   ; send 80 warmup pulses to sclk while cs is high
                   sd_warmup:
00F6: C0 E0                push    acc
00F8: C0 F0                push    b
00FA: D2 91                setb    sd_pin_cs ; p1.1
00FC: 75 F0 0A             mov     b,#10
                   sd_warmup_loop:
00FF: 74 FF                mov     a,#0xff
0101: 11 A5                acall   spi_transfer
0103: D5 F0 F9             djnz    b,sd_warmup_loop
0106: D0 F0                pop     b
0108: D0 E0                pop     acc
010A: 22                   ret
                   
                   ; *** sd/select.inc ***
                   
                   ; >> void sd_select() <<
                   
                   ; Activate the SD card
                   sd_select:
010B: C0 E0                push    acc
010D: 74 FF                mov     a,#0xff
010F: 11 A5                acall   spi_transfer
0111: C2 91                clr     sd_pin_cs
0113: 74 FF                mov     a,#0xff
0115: 11 A5                acall   spi_transfer
0117: D0 E0                pop     acc
0119: 22                   ret
                   
                   ; *** sd/deselect.inc ***
                   
                   ; >> void sd_deselect() <<
                   
                   ; Deactivate the SD card
                   sd_deselect:
011A: C0 E0                push    acc
011C: 74 FF                mov     a,#0xff
011E: 11 A5                acall   spi_transfer
0120: D2 91                setb    sd_pin_cs
0122: 74 FF                mov     a,#0xff
0124: 11 A5                acall   spi_transfer
0126: D0 E0                pop     acc
0128: 22                   ret
                   
                   ; *** sd/command.inc ***
                   
                   ; >> void sd_command(uint8{a} cmd, uint32{r0-r3} arg, uint8{
                   
                   ; Issue a command to the SD card
                   sd_command:
0129: C0 E0                push    acc
                           ; transmit command
012B: 44 40                orl     a,#0x40 ; transmission bit
012D: 11 A5                acall   spi_transfer
                           ; transmit argument
012F: EB                   mov     a,r3
0130: 11 A5                acall   spi_transfer
0132: EA                   mov     a,r2
0133: 11 A5                acall   spi_transfer
0135: E9                   mov     a,r1
0136: 11 A5                acall   spi_transfer
0138: E8                   mov     a,r0
0139: 11 A5                acall   spi_transfer
                           ; transmit crc
013B: EC                   mov     a,r4
013C: 44 01                orl     a,#0x01 ; end bit
013E: 11 A5                acall   spi_transfer
0140: D0 E0                pop     acc
0142: 22                   ret
                   
                   ; *** sd/response.inc ***
                   
                   ; >> uint8{a} sd_response1() <<
                   
                   ; Read response from SD card in 'R1' format into a
                   sd_response1:
0143: C0 F0                push    b
0145: 85 08 F0             mov     b,8     ; number of tries
                   sd_response1__loop:
0148: 74 FF                mov     a,#0xff
014A: 11 A5                acall   spi_transfer
014C: B4 FF 03             cjne    a,#0xff,sd_response1__end       ; success
014F: D5 F0 F6             djnz    b,sd_response1__loop    ; retry / timeout
                   sd_response1__end:
0152: D0 F0                pop     b
0154: 22                   ret
                   
                   ; >> uint8{a}, uint32{r0-r3} sd_response3() <<
                   
                   ; Read response from SD card in 'R3' format into a and r0-r3
                   sd_response3: ; same as R7
                   
                   ; >> uint8{a}, uint32{r0-r3} sd_response7() <<
                   
                   ; Read response from SD card in 'R7' format into a and r0-r3
                   sd_response7:
0155: 31 43                acall   sd_response1
0157: B4 02 00             cjne    a,#0x02,sd_response7__1
                   sd_response7__1:
015A: 40 01                jc      sd_response7__2
015C: 22                   ret     ; error in R1 response
                   sd_response7__2:
015D: F8                   mov     r0,a
015E: 74 FF                mov     a,#0xff
0160: 11 A5                acall   spi_transfer
0162: FB                   mov     r3,a
0163: 74 FF                mov     a,#0xff
0165: 11 A5                acall   spi_transfer
0167: FA                   mov     r2,a
0168: 74 FF                mov     a,#0xff
016A: 11 A5                acall   spi_transfer
016C: F9                   mov     r1,a
016D: 74 FF                mov     a,#0xff
016F: 11 A5                acall   spi_transfer
0171: C8                   xch     a,r0
0172: 22                   ret
                   
                   ; *** sd/cmd0.inc ***
                   
                   ; >> char{a} sd_cmd0() <<
                   
                   ; CMD0: go to idle state
                   sd_cmd0:
0173: 51 6B                acall   regbank_next
0175: E4                   clr     a
0176: F8                   mov     r0,a
0177: F9                   mov     r1,a
0178: FA                   mov     r2,a
0179: FB                   mov     r3,a
017A: 7C 94                mov     r4,#0x94
017C: 31 29                acall   sd_command
017E: 31 43                acall   sd_response1
0180: 51 84                acall   regbank_prev
0182: 22                   ret
                   
                   ; *** sd/cmd8.inc ***
                   
                   ; >> uint8{a},uint32{r0-r3} sd_cmd8() <<
                   
                   ; CMD8: send interface condition
                   sd_cmd8:
0183: EC                   mov     a,r4
0184: C0 E0                push    acc
0186: 74 08                mov     a,#8
0188: 78 AA                mov     r0,#0xaa
018A: 79 01                mov     r1,#0x01
018C: 7A 00                mov     r2,#0x00
018E: 7B 00                mov     r3,#0x00
0190: 7C 86                mov     r4,#0x86
0192: 31 29                acall   sd_command
0194: 31 55                acall   sd_response7
0196: FC                   mov     r4,a
0197: D0 E0                pop     acc
0199: CC                   xch     a,r4
019A: 22                   ret
                   
                   ; *** sd/cmd55.inc ***
                   
                   ; >> char{a} sd_cmd55() <<
                   
                   ; CMD55: application specific command (prefix)
                   sd_cmd55:
019B: 51 6B                acall   regbank_next
019D: E4                   clr     a
019E: F8                   mov     r0,a
019F: F9                   mov     r1,a
01A0: FA                   mov     r2,a
01A1: FB                   mov     r3,a
01A2: FC                   mov     r4,a
01A3: 74 37                mov     a,#55
01A5: 31 29                acall   sd_command
01A7: 31 43                acall   sd_response1
01A9: 51 84                acall   regbank_prev
01AB: 22                   ret
                   
                   ; *** sd/cmd58.inc ***
                   
                   ; >> uint8{a},uint32{r0-r3} sd_cmd58() <<
                   
                   ; CMD58: read operation conditions register
                   sd_cmd58:
01AC: EC                   mov     a,r4
01AD: C0 E0                push    acc
01AF: E4                   clr     a
01B0: F8                   mov     r0,a
01B1: F9                   mov     r1,a
01B2: FA                   mov     r2,a
01B3: FB                   mov     r3,a
01B4: FC                   mov     r4,a
01B5: 74 3A                mov     a,#58
01B7: 31 29                acall   sd_command
01B9: 31 55                acall   sd_response3
01BB: FC                   mov     r4,a
01BC: D0 E0                pop     acc
01BE: CC                   xch     a,r4
01BF: 22                   ret
                   
                   ; *** sd/acmd41.inc ***
                   
                   ; >> char{a} sd_acmd41() <<
                   
                   ; ACMD41: send operation condition
                   sd_acmd41:
01C0: 31 9B                acall   sd_cmd55
01C2: B4 01 11             cjne    a,#1,sd_acmd41__end
01C5: 51 6B                acall   regbank_next
01C7: E4                   clr     a
01C8: F8                   mov     r0,a
01C9: F9                   mov     r1,a
01CA: FA                   mov     r2,a
01CB: 7B 40                mov     r3,#0x40 ; indicates high capacity support
01CD: FC                   mov     r4,a
01CE: 74 29                mov     a,#41
01D0: 31 29                acall   sd_command
01D2: 31 43                acall   sd_response1
01D4: 51 84                acall   regbank_prev
                   sd_acmd41__end:
01D6: 22                   ret
                   
                   ; *** serial/init.inc ***
                   
                   ; >> void serial_init() <<
                   
                   ; Initialize serial interface.
                   ; - assumes 20MHz clock and X2 mode
                   ; - uses internal baud rate generator
                   ; - speed: 9600 bits per second
                   ; Formula: BRL = 256 - (F_clk / (32 * Baud_Rate))
                   ; ---
                   ; See datasheet page 52 for details,
                   ; also note oscillator diagram on page 16!
                   
                   serial_init:
01D7: 75 98 52             mov     SCON,   #0x52   ; SM1, REN, TI
01DA: 75 9A BF             mov     BRL,    #191    ; 9600 @20MHz CLK
01DD: 75 9B 1E             mov     BDRCON, #0x1e   ; BRR, RBCK, TBCK, SPD
                   
01E0: 90 01 F3             mov     dptr,   #serial_rx
01E3: 85 82 30             mov     IN,     DPL
01E6: 85 83 31             mov     IN+1,   DPH
                   
01E9: 90 01 FB             mov     dptr,   #serial_tx
01EC: 85 82 32             mov     OUT,    DPL
01EF: 85 83 33             mov     OUT+1,  DPH
                   
01F2: 22                   ret
                   
                   ; *** serial/rx.inc ***
                   
                   ; >> char serial_rx <<
                   
                   ; Receive byte into accumulator.
                   
                   serial_rx:
01F3: 30 98 FD             jnb     RI,     serial_rx
01F6: C2 98                clr     RI
01F8: E5 99                mov     a,      SBUF
01FA: 22                   ret
                   
                   ; *** serial/tx.inc ***
                   
                   ; >> void serial_tx(char a) <<
                   
                   ; Transmit byte from accumulator.
                   
                   serial_tx:
01FB: 30 99 FD             jnb     TI,     serial_tx
01FE: C2 99                clr     TI
0200: F5 99                mov     SBUF,   a
0202: 22                   ret
                   
                   ; *** print/char.inc ***
                   
                   ; >> void print_char(char a) <<
                   
                   ; Print char from accumulator.
                   ; Indirect call to function behind OUT pointer.
                   
                   print_char:
0203: C0 32                push    OUT
0205: C0 33                push    OUT+1
0207: 22                   ret
                   
                   ; *** print/hex.inc ***
                   
                   ; >> void print_hex_8(char a) <<
                   
                   ; Print hexadecimal number from accumulator.
                   
                   print_hex_8:
0208: C4                   swap    a       ; high nibble first
0209: 51 0C                acall   print_hex_8__nibble
020B: C4                   swap    a
                   print_hex_8__nibble:
020C: C0 E0                push    ACC
020E: 54 0F                anl     a,      #0x0f
0210: 24 90                add     a,      #0x90
0212: D4                   da      a
0213: 34 40                addc    a,      #0x40
0215: D4                   da      a
0216: 44 20                orl     a,      #0x20   ; lower case
0218: 51 03                acall   print_char
021A: D0 E0                pop     ACC
021C: 22                   ret
                   
                   ; >> void print_hex_16(int r0r1) <<
                   
                   ; Print hexadecimal number from r0-r1.
                   
                   print_hex_16:
021D: C0 E0                push    ACC
021F: E9                   mov     a,      r1      ; MSB first
0220: 51 08                acall   print_hex_8
0222: E8                   mov     a,      r0      ; LSB second
0223: 51 08                acall   print_hex_8
0225: D0 E0                pop     ACC
0227: 22                   ret
                   
                   ; >> void print_hex_32(long r0r1r2r3) <<
                   
                   ; Print hexadecimal number from r0-r3.
                   
                   print_hex_32:
0228: C0 E0                push    ACC
022A: EB                   mov     a,      r3      ; MSB first
022B: 51 08                acall   print_hex_8
022D: EA                   mov     a,      r2
022E: 51 08                acall   print_hex_8
0230: E9                   mov     a,      r1
0231: 51 08                acall   print_hex_8
0233: E8                   mov     a,      r0      ; LSB last
0234: 51 08                acall   print_hex_8
0236: D0 E0                pop     ACC
0238: 22                   ret
                   
                   ; *** print/text.inc ***
                   
                   ; >> void print_text(char* dptr) <<
                   
                   ; Print null-terminated string from program code.
                   ; Aborts if no null terminator is found after 256 bytes.
                   
                   print_text:
0239: C0 E0                push    ACC
023B: E8                   mov     a,      r0
023C: C0 E0                push    ACC
                   
023E: E4                   clr     a
023F: F8                   mov     r0,     a
                   print_text__loop:
0240: 93                   movc    a,      @dptr+a
0241: 60 06                jz      print_text__end
0243: 51 03                acall   print_char
0245: 08                   inc     r0
0246: E8                   mov     a,      r0
0247: 70 F7                jnz     print_text__loop
                   
                   print_text__end:
0249: D0 E0                pop     ACC
024B: F8                   mov     r0,     a
024C: D0 E0                pop     ACC
024E: 22                   ret
                   
                   ; *** util/delay.inc ***
                   
                   ; >> void delay_ms_8(uint8{a} duration) <<
                   
                   ; 1-256 millisecond delay, duration given in a.
                   ; Assumes 20MHz clock and X2 mode.
                   ; Actual delay is slightly longer.
                   delay_ms_8:
                   
024F: C0 E0                push    acc
0251: C0 F0                push    b
                   
                           ; This loop is repeated a times (256 if a is zero).
                           ; The goal is to stretch each repeat to one millisec
                   delay_ms_8__loop1:
                           ; Each millisecond is 20k clock periods.
                           ; In X2 mode, a machine cycle is 6 clock periods.
                           ; Therefore, a millisecond is approx. 3334 machine c
0253: 75 F0 B9             mov     b,#185  ; n = 185       cycles:   2
                   delay_ms_8__loop2:
0256: C0 E0                push    acc                     ; n*2 = 370
0258: C0 F0                push    b                       ; n*2 = 370
025A: A4                   mul     ab                      ; n*4 = 740
025B: A4                   mul     ab                      ; n*4 = 740
025C: D0 F0                pop     b                       ; n*2 = 370
025E: D0 E0                pop     acc                     ; n*2 = 370
0260: D5 F0 F3             djnz    b,delay_ms_8__loop2     ; n*2 = 370
0263: D5 E0 ED             djnz    acc,delay_ms_8__loop1   ;         2
                                                           ; Sum: 3334
0266: D0 F0                pop     b
0268: D0 E0                pop     acc
026A: 22                   ret
                   
                   ; *** util/regbank.inc ***
                   
                   ; >> void* regbank_next() <<
                   
                   ; Switch to next register bank.
                   ; Return pointer to r0 of old bank in new r0.
                   
                   regbank_next:
026B: C0 E0                push    acc
                           ; check if already at highest bank
026D: E5 D0                mov     a,      psw
026F: 54 18                anl     a,      #0x18
0271: B4 18 02             cjne    a,      #0x18,  regbank_next__continue
0274: 51 97                acall   panic   ; overflow
                   regbank_next__continue:
                           ; switch to next bank
0276: E5 D0                mov     a,      psw
0278: 24 08                add     a,      #0x08
027A: F5 D0                mov     psw,    a
                           ; calculate pointer to old bank
027C: 54 18                anl     a,      #0x18
027E: 24 F8                add     a,      #0xf8
0280: F8                   mov     r0,     a
                           ; done
0281: D0 E0                pop     acc
0283: 22                   ret
                   
                   ; >> void regbank_prev() <<
                   
                   ; Switch to previous register bank.
                   
                   regbank_prev:
0284: C0 E0                push    acc
                           ; check if already at lowest bank
0286: E5 D0                mov     a,      psw
0288: 54 18                anl     a,      #0x18
028A: 70 02                jnz     regbank_prev__continue
028C: 51 97                acall   panic   ; underflow
                   regbank_prev__continue:
                           ; switch to previous bank
028E: E5 D0                mov     a,      psw
0290: 24 F8                add     a,      #0xf8
0292: F5 D0                mov     psw,    a
                           ; done
0294: D0 E0                pop     acc
0296: 22                   ret
0297:              .equ panic_out, serial_tx
                   
                   ; *** panic/panic.inc ***
                   
                   ; >> void panic() <<
                   
                   ; Unrecoverable error handler.
                   ; Print caller address and halt.
                   
                   panic:
0297: C2 AF                clr     ea      ; disable interrupts
0299: 90 01 FB             mov     dptr,   #panic_out
029C: 85 82 32             mov     out,    dpl
029F: 85 83 33             mov     out+1,  dph
02A2: 90 02 B1             mov     dptr,   #panic_text
02A5: 51 39                acall   print_text
02A7: D0 E0                pop     acc
02A9: 51 08                acall   print_hex_8
02AB: D0 E0                pop     acc
02AD: 51 08                acall   print_hex_8
02AF: 80 FE                sjmp    *
                   
                   panic_text:
02B1: 0D 0A                .db     13, 10
02B3: 20 21 21 21 
      20 70 61 6E 
      69 63 20 40 
                           .db     " !!! panic @"
02BF: 00                   .db     0
